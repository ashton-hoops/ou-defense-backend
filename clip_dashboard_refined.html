<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>OU WBB Defensive Clip Library ‚Äî 2025-26</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
<style>
:root {
  /* OU Brand */
  --ou-crimson: #841617;
  --ou-crimson-dark: #6C1116;
  --cream: #FDF9E8;
  
  /* Backgrounds */
  --bg-page: #141414;
  --bg-panel: #1a1a1a;
  --bg-panel-hover: #202020;
  --bg-card: #1c1c1c;
  --bg-input: #252525;
  
  /* Borders */
  --border-main: #2a2a2a;
  --border-subtle: #333;
  
  /* Text */
  --text-primary: #f5f5f2;
  --text-muted: #c9c6c0;
  --text-dim: #7f7f7f;
  
  /* Status Colors */
  --stop-green: #166534;
  --breakdown-red: #872021;
  --blue-shooter: #3b82f6;
  --green-shooter: #22c55e;
  --black-shooter: #6b7280;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif;
  background: var(--bg-page);
  color: var(--text-primary);
  line-height: 1.5;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

.mono {
  font-family: 'JetBrains Mono', monospace;
}

/* Header */
.header {
  background: linear-gradient(180deg, #1a1a1a, #151515);
  border-bottom: 1px solid var(--border-main);
  padding: 0.75rem 1.5rem;
  position: sticky;
  top: 0;
  z-index: 100;
}

.header-content {
  max-width: 1600px;
  margin: 0 auto;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.header h1 {
  font-size: 1rem;
  font-weight: 600;
  letter-spacing: 0.25px;
}

.header-subtitle {
  color: var(--text-muted);
  font-size: 0.8125rem;
  margin-top: 0.125rem;
}

.accent-bar {
  height: 3px;
  background: linear-gradient(90deg, var(--cream), transparent, var(--cream));
  opacity: 0.45;
}

/* Main Container */
.container {
  max-width: 1600px;
  margin: 0 auto;
  padding: 2rem;
}

/* Filter Bar */
.filter-bar {
  background: var(--bg-panel);
  border: 1px solid var(--border-main);
  border-radius: 12px;
  padding: 1.5rem;
  margin-bottom: 2rem;
}

.filter-section {
  display: flex;
  gap: 1rem;
  align-items: center;
  flex-wrap: wrap;
}

.filter-label {
  font-size: 0.875rem;
  color: var(--text-muted);
  font-weight: 500;
}

.radio-group {
  display: flex;
  gap: 0.5rem;
  background: var(--bg-page);
  padding: 0.25rem;
  border-radius: 8px;
  border: 1px solid var(--border-subtle);
}

.radio-btn {
  padding: 0.5rem 1rem;
  background: transparent;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  border-radius: 6px;
  font-size: 0.875rem;
  transition: all 0.2s;
  font-family: inherit;
}

.radio-btn:hover {
  color: var(--text-primary);
}

.radio-btn.active {
  background: var(--ou-crimson);
  color: white;
}

.search-box {
  flex: 1;
  min-width: 250px;
  position: relative;
}

.search-box input {
  width: 100%;
  padding: 0.625rem 1rem;
  background: var(--bg-input);
  border: 1px solid var(--border-subtle);
  border-radius: 8px;
  color: var(--text-primary);
  font-size: 0.875rem;
  font-family: inherit;
}

.search-box input:focus {
  outline: none;
  border-color: var(--ou-crimson);
}

.filter-toggle-btn {
  padding: 0.625rem 1.25rem;
  background: var(--ou-crimson);
  border: none;
  color: white;
  cursor: pointer;
  border-radius: 8px;
  font-size: 0.875rem;
  font-weight: 500;
  transition: all 0.2s;
  font-family: inherit;
}

.filter-toggle-btn:hover {
  background: var(--ou-crimson-dark);
}

/* Stats Bar */
.stats-bar {
  display: flex;
  gap: 2rem;
  padding: 1rem 1.5rem;
  background: var(--bg-panel);
  border: 1px solid var(--border-main);
  border-radius: 12px;
  margin-bottom: 2rem;
}

.stat {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.stat-label {
  font-size: 0.75rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: 600;
  font-family: 'JetBrains Mono', monospace;
}

/* Game Grid */
.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1.5rem;
}

.section-title {
  font-size: 1.25rem;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.view-toggle {
  display: flex;
  gap: 0.5rem;
}

.view-btn {
  padding: 0.5rem 1rem;
  background: var(--bg-panel);
  border: 1px solid var(--border-subtle);
  color: var(--text-muted);
  cursor: pointer;
  border-radius: 6px;
  font-size: 0.875rem;
  transition: all 0.2s;
  font-family: inherit;
}

.view-btn.active {
  background: var(--ou-crimson);
  color: white;
  border-color: var(--ou-crimson);
}

.games-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));
  gap: 1.5rem;
  margin-bottom: 3rem;
}

.games-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.875rem;
}

.games-table thead {
  background: var(--bg-panel);
  position: sticky;
  top: 0;
  z-index: 10;
}

.games-table th {
  padding: 0.75rem 1rem;
  text-align: left;
  font-weight: 600;
  font-size: 0.75rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-right: 1px solid var(--border-subtle);
  border-bottom: 2px solid var(--ou-crimson);
  white-space: nowrap;
}

.games-table th:first-child {
  text-align: center;
  width: 60px;
}

.games-table td {
  padding: 1rem;
  border-bottom: 1px solid var(--border-subtle);
  border-right: 1px solid var(--border-subtle);
  color: var(--text-primary);
}

.games-table td:first-child {
  text-align: center;
  font-weight: 700;
  font-family: 'JetBrains Mono', monospace;
  font-size: 1rem;
}

.games-table tbody tr {
  cursor: pointer;
  transition: background 0.15s;
}

.games-table tbody tr:hover {
  background: var(--bg-panel-hover);
}

.table-opponent {
  font-weight: 600;
  font-size: 1rem;
}

.table-location {
  display: inline-block;
  padding: 0.25rem 0.5rem;
  background: var(--bg-input);
  border-radius: 4px;
  font-size: 0.7rem;
  margin-left: 0.5rem;
  text-transform: uppercase;
}

.table-score {
  font-family: 'JetBrains Mono', monospace;
  font-weight: 600;
  font-size: 0.875rem;
}

.table-score.win {
  color: var(--stop-green);
}

.table-score.loss {
  color: var(--breakdown-red);
}

.table-stat {
  font-family: 'JetBrains Mono', monospace;
  font-weight: 600;
}

.game-card {
  background: var(--bg-card);
  border: 1px solid var(--border-main);
  border-radius: 12px;
  overflow: hidden;
  cursor: pointer;
  transition: all 0.2s;
}

.game-card:hover {
  border-color: var(--ou-crimson);
  transform: translateY(-2px);
  box-shadow: 0 8px 24px rgba(132, 22, 23, 0.2);
}

.game-header {
  padding: 1.25rem;
  border-bottom: 1px solid var(--border-subtle);
}

.game-number {
  font-size: 0.75rem;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  font-family: 'JetBrains Mono', monospace;
}

.game-opponent {
  font-size: 1.25rem;
  font-weight: 600;
  margin-top: 0.25rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.location-badge {
  font-size: 0.625rem;
  padding: 0.25rem 0.5rem;
  background: var(--bg-page);
  border-radius: 4px;
  color: var(--text-muted);
  text-transform: uppercase;
  font-weight: 500;
  letter-spacing: 0.5px;
}

.game-score {
  font-size: 1rem;
  font-family: 'JetBrains Mono', monospace;
  margin-top: 0.5rem;
}

.score-win {
  color: var(--stop-green);
}

.score-loss {
  color: var(--breakdown-red);
}

.game-stats {
  padding: 1.25rem;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 1rem;
}

.game-stat {
  text-align: center;
}

.game-stat-value {
  font-size: 1.25rem;
  font-weight: 600;
  font-family: 'JetBrains Mono', monospace;
}

.game-stat-label {
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-top: 0.25rem;
}

/* Clips Grid */
.clips-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 1.5rem;
}

.clip-card {
  background: var(--bg-card);
  border: 1px solid var(--border-main);
  border-radius: 12px;
  overflow: hidden;
  cursor: pointer;
  transition: all 0.2s;
}

.clip-card:hover {
  border-color: var(--ou-crimson);
  transform: translateY(-2px);
  box-shadow: 0 8px 24px rgba(132, 22, 23, 0.2);
}

.clip-thumbnail {
  position: relative;
  width: 100%;
  aspect-ratio: 16/9;
  background: #000;
  overflow: hidden;
}

.clip-thumbnail video {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.play-overlay {
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.3);
  opacity: 0;
  transition: opacity 0.2s;
}

.clip-card:hover .play-overlay {
  opacity: 1;
}

.play-icon {
  width: 60px;
  height: 60px;
  background: rgba(132, 22, 23, 0.9);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px solid white;
}

.play-icon::after {
  content: '';
  width: 0;
  height: 0;
  border-left: 18px solid white;
  border-top: 12px solid transparent;
  border-bottom: 12px solid transparent;
  margin-left: 4px;
}

.clip-badges {
  position: absolute;
  top: 0.75rem;
  left: 0.75rem;
  display: flex;
  gap: 0.5rem;
}

.badge {
  padding: 0.25rem 0.625rem;
  border-radius: 6px;
  font-size: 0.75rem;
  font-weight: 600;
  font-family: 'JetBrains Mono', monospace;
  backdrop-filter: blur(8px);
}

.badge-quarter {
  background: rgba(26, 26, 26, 0.9);
  border: 1px solid var(--border-subtle);
}

.clip-info {
  padding: 1rem;
}

.clip-game {
  font-size: 0.75rem;
  color: var(--text-dim);
  font-family: 'JetBrains Mono', monospace;
}

.clip-play {
  font-size: 1rem;
  font-weight: 600;
  margin-top: 0.25rem;
  color: var(--text-primary);
}

.clip-tags {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-top: 0.75rem;
}

.tag {
  padding: 0.25rem 0.625rem;
  border-radius: 6px;
  font-size: 0.75rem;
  font-weight: 500;
}

.tag-breakdown {
  background: rgba(135, 32, 33, 0.2);
  color: #ff6b6b;
  border: 1px solid rgba(135, 32, 33, 0.4);
}

.tag-stop {
  background: rgba(22, 101, 52, 0.2);
  color: #4ade80;
  border: 1px solid rgba(22, 101, 52, 0.4);
}

.tag-blue {
  background: rgba(59, 130, 246, 0.2);
  color: #60a5fa;
  border: 1px solid rgba(59, 130, 246, 0.4);
}

.tag-green {
  background: rgba(34, 197, 94, 0.2);
  color: #4ade80;
  border: 1px solid rgba(34, 197, 94, 0.4);
}

.tag-black {
  background: rgba(107, 114, 128, 0.2);
  color: #9ca3af;
  border: 1px solid rgba(107, 114, 128, 0.4);
}

.tag-points {
  background: rgba(253, 249, 232, 0.1);
  color: var(--cream);
  border: 1px solid rgba(253, 249, 232, 0.2);
  font-family: 'JetBrains Mono', monospace;
}

/* Filter Panel */
.filter-panel {
  position: fixed;
  right: 0;
  top: 0;
  bottom: 0;
  width: 400px;
  background: var(--bg-panel);
  border-left: 1px solid var(--border-main);
  transform: translateX(100%);
  transition: transform 0.3s ease;
  z-index: 200;
  overflow-y: auto;
  box-shadow: -8px 0 24px rgba(0, 0, 0, 0.5);
}

.filter-panel.open {
  transform: translateX(0);
}

.filter-panel-header {
  position: sticky;
  top: 0;
  background: var(--bg-panel);
  border-bottom: 1px solid var(--border-subtle);
  padding: 1.5rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  z-index: 10;
}

.filter-panel-title {
  font-size: 1.125rem;
  font-weight: 600;
}

.close-btn {
  width: 32px;
  height: 32px;
  background: var(--bg-input);
  border: none;
  border-radius: 6px;
  color: var(--text-primary);
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.25rem;
  transition: all 0.2s;
}

.close-btn:hover {
  background: var(--ou-crimson);
}

.filter-panel-content {
  padding: 1.5rem;
}

.filter-group { margin-bottom: 1.25rem; border-bottom:1px solid var(--border-subtle); padding-bottom:0.5rem; }
.filter-group:last-child { border-bottom:none; }
.filter-group-title {
  font-size:0.82rem; font-weight:600; text-transform:uppercase; letter-spacing:0.45px;
  color:var(--text-muted); display:flex; align-items:center; justify-content:space-between;
  cursor:pointer; padding:0.35rem 0; user-select:none; transition:color 0.2s ease;
}
.filter-group-title:hover { color:var(--cream); }
.filter-group-title::after {
  content:'‚àí'; font-size:0.9rem; color:var(--text-primary); transition:transform 0.2s ease;
}
.filter-group.collapsed .filter-group-title::after { content:'+'; }
.filter-group.collapsed .checkbox-group { display:none; }
.filter-group.collapsed .filter-search-group { display:none; }
.checkbox-group { display:flex; flex-direction:column; gap:0.45rem; padding-left:0.2rem; }
.checkbox-item { display:flex; align-items:center; gap:0.65rem; padding:0.35rem 0.4rem; border-radius:6px; transition:background 0.2s ease; }
.checkbox-item:hover { background:rgba(132,22,23,0.12); }
.checkbox-item input { width:18px; height:18px; cursor:pointer; accent-color:var(--ou-crimson); }
.checkbox-item label { cursor:pointer; font-size:0.85rem; flex:1; color:#d1d5db; }
.filter-search-group { display:flex; flex-direction:column; gap:0.6rem; padding-left:0.2rem; }
.filter-search-field { display:flex; flex-direction:column; gap:0.35rem; }
.filter-search-field label { font-size:0.78rem; color:#9ca3af; text-transform:uppercase; letter-spacing:0.4px; }
.filter-search-field input { background:#101010; color:#f5f5f2; border:1px solid #2f2f2f; border-radius:8px; padding:0.55rem 0.65rem; font-size:0.85rem; }
.filter-search-field input:focus { outline:2px solid var(--ou-crimson); outline-offset:1px; }

.filter-panel-footer {
  position: sticky;
  bottom: 0;
  background: var(--bg-panel);
  border-top: 1px solid var(--border-subtle);
  padding: 1.5rem;
  display: flex;
  gap: 1rem;
}

.btn {
  flex: 1;
  padding: 0.75rem;
  border: none;
  border-radius: 8px;
  font-size: 0.875rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  font-family: inherit;
}

.btn-clear {
  background: var(--bg-input);
  color: var(--text-primary);
  border: 1px solid var(--border-subtle);
}

.btn-clear:hover {
  background: var(--bg-panel-hover);
}

.btn-apply {
  background: var(--ou-crimson);
  color: white;
}

.btn-apply:hover {
  background: var(--ou-crimson-dark);
}

/* Overlay */
.overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 150;
  display: none;
}

.overlay.active {
  display: block;
}

/* Spreadsheet List View */
.spreadsheet-view {
  display: none;
  background: var(--bg-card);
  border: 1px solid var(--border-main);
  border-radius: 12px;
  overflow: hidden;
}

.spreadsheet-view.active {
  display: block;
}

.spreadsheet-wrapper {
  overflow: auto;
  max-height: 800px;
}

.spreadsheet-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.75rem;
}

.spreadsheet-table thead {
  position: sticky;
  top: 0;
  z-index: 10;
  background: var(--bg-panel);
}

.spreadsheet-table th {
  padding: 0.65rem 0.75rem;
  text-align: left;
  font-weight: 600;
  font-size: 0.7rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  border-right: 1px solid var(--border-subtle);
  border-bottom: 2px solid var(--ou-crimson);
  white-space: nowrap;
  min-width: 80px;
  background: var(--bg-panel);
}

.spreadsheet-table th:first-child {
  min-width: 40px;
  text-align: center;
}

.spreadsheet-table td {
  padding: 0.6rem 0.75rem;
  border-bottom: 1px solid var(--border-subtle);
  border-right: 1px solid var(--border-subtle);
  color: var(--text-primary);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  max-width: 200px;
}

.spreadsheet-table td:first-child {
  text-align: center;
  font-weight: 600;
  color: var(--text-muted);
  font-family: 'JetBrains Mono', monospace;
}

.spreadsheet-table tbody tr {
  cursor: pointer;
  transition: background 0.15s;
}

.spreadsheet-table tbody tr:hover {
  background: var(--bg-panel-hover);
}

.empty-cell {
  color: var(--text-dim);
  font-style: italic;
}

/* Overlay */
.overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  z-index: 150;
  display: none;
}

.overlay.active {
  display: block;
}

/* Active Filters */
.active-filters {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  align-items: center;
  margin-bottom: 1.5rem;
}

.active-filter-chip {
  padding: 0.5rem 1rem;
  background: var(--bg-card);
  border: 1px solid var(--border-subtle);
  border-radius: 8px;
  font-size: 0.875rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.remove-filter {
  color: var(--text-dim);
  cursor: pointer;
  font-weight: bold;
}

.remove-filter:hover {
  color: var(--ou-crimson);
}

/* Shot Chart */
.shot-chart-panel {
  background: var(--bg-panel);
  border: 1px solid var(--border-main);
  border-radius: 12px;
  margin-bottom: 2rem;
  overflow: hidden;
}

.shot-chart-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 1rem 1.5rem;
  cursor: pointer;
  user-select: none;
  transition: background 0.2s;
}

.shot-chart-header:hover {
  background: var(--bg-panel-hover);
}

.shot-chart-header-left {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.shot-chart-collapse-icon {
  font-size: 1.25rem;
  color: var(--text-muted);
  transition: transform 0.2s;
}

.shot-chart-panel.collapsed .shot-chart-collapse-icon {
  transform: rotate(-90deg);
}

.shot-chart-title {
  font-size: 1.125rem;
  font-weight: 600;
}

.shot-chart-meta {
  font-size: 0.875rem;
  color: var(--text-muted);
}

.shot-chart-body {
  padding: 0 1.5rem 1.5rem 1.5rem;
  transition: max-height 0.3s ease, opacity 0.3s ease;
  max-height: 1000px;
  opacity: 1;
}

.shot-chart-panel.collapsed .shot-chart-body {
  max-height: 0;
  opacity: 0;
  padding-top: 0;
  padding-bottom: 0;
  overflow: hidden;
}

.shot-court-container {
  position: relative;
  width: 100%;
  max-width: 450px;
  margin: 0 auto;
}

.shot-court-container::before {
  content: '';
  display: block;
  padding-bottom: 100%;
}

.shot-court-bg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  background-image: url('assets/shot_court.webp');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  border-radius: 8px;
  z-index: 1;
}

.shot-overlay-svg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 2;
}

.shot-marker {
  cursor: pointer;
  pointer-events: all;
  transition: opacity 0.2s;
}

.shot-marker:hover {
  opacity: 0.8;
}

.shot-marker-ring {
  fill: none;
  stroke: rgba(255, 255, 255, 0.5);
  stroke-width: 0.5;
}

.shot-tooltip {
  position: fixed;
  background: rgba(20, 20, 20, 0.75);
  color: white;
  padding: 0.5rem 0.75rem;
  border-radius: 6px;
  font-size: 0.75rem;
  pointer-events: none;
  z-index: 1000;
  display: none;
  backdrop-filter: blur(4px);
  border: 1px solid rgba(255, 255, 255, 0.1);
}

.shot-tooltip-line {
  margin: 0.125rem 0;
}

.shot-legend {
  display: flex;
  gap: 1.5rem;
  justify-content: center;
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border-subtle);
  font-size: 0.875rem;
  color: var(--text-muted);
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
}

.no-shots-message {
  text-align: center;
  padding: 2rem;
  color: var(--text-dim);
  font-size: 0.875rem;
}

/* Hidden class */
.hidden {
  display: none !important;
}

/* Responsive */
@media (max-width: 768px) {
  .filter-panel {
    width: 100%;
  }
  
  .games-grid {
    grid-template-columns: 1fr;
  }
  
  .clips-grid {
    grid-template-columns: 1fr;
  }
}
</style>
<script src="scripts/shared/location.js"></script>
</head>
<body>
  <!-- Main Container -->
  <div class="container" style="padding-top: 24px;">
    <!-- Filter Bar -->
    <div class="filter-bar">
      <div class="filter-section">
        <span class="filter-label">VIEW:</span>
        <div class="radio-group">
          <button class="radio-btn active" data-view="all">All</button>
          <button class="radio-btn" data-view="home">Home</button>
          <button class="radio-btn" data-view="away">Away</button>
          <button class="radio-btn" data-view="neutral">Neutral</button>
        </div>
        <div class="search-box">
          <input type="text" placeholder="Search opponent..." id="opponentSearch">
        </div>
        <button class="filter-toggle-btn" id="filterToggle">+ Add Clip Filters</button>
      </div>
    </div>

    <!-- Stats Bar -->
    <div class="stats-bar" id="statsBar"></div>

    <!-- Games Grid -->
    <div class="section-header">
      <h2 class="section-title">Games</h2>
    </div>

    <div class="games-grid" id="gamesGrid">
      <!-- Games will be populated here -->
    </div>

    <!-- Clips Grid (Hidden by default) -->
    <div id="clipsSection" class="hidden">
      <button class="btn btn-clear" id="backToGamesBtn" style="margin-bottom: 1.5rem; display: inline-flex; align-items: center; gap: 0.5rem;">
        ‚Üê Back to Games
      </button>

      <!-- Shot Chart Panel -->
      <div id="shotChartPanel" class="shot-chart-panel hidden">
        <div class="shot-chart-header" id="shotChartToggle">
          <div class="shot-chart-header-left">
            <div class="shot-chart-collapse-icon">‚ñº</div>
            <div>
              <div class="shot-chart-title" id="shotChartTitle">Shot Chart</div>
            </div>
          </div>
          <div style="display: flex; align-items: center; gap: 1rem;">
            <div class="shot-chart-meta" id="shotChartMeta"></div>
            <button id="editShotChartBtn" class="btn btn-secondary" style="font-size: 0.875rem; padding: 0.5rem 1rem;">Edit</button>
          </div>
        </div>
        <div class="shot-chart-body">
          <div id="shotChartContainer"></div>
          <div class="shot-legend">
            <div class="legend-item">
              <div class="legend-dot designation-blue"></div>
              <span>Blue (Primary)</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot designation-green"></div>
              <span>Green (Shooter)</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot designation-black"></div>
              <span>Black (Role)</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot result-made"></div>
              <span>Made</span>
            </div>
            <div class="legend-item">
              <div class="legend-dot result-missed"></div>
              <span>Missed</span>
            </div>
          </div>
        </div>
      </div>
      <div class="shot-tooltip" id="shotTooltip"></div>

      <!-- Shot Editor Modal -->
      <div id="shotEditorModal" class="modal-overlay" style="display: none;">
        <div class="modal-box" style="max-width: 500px;">
          <div class="modal-title">Edit Shot</div>
          <div style="margin: 1rem 0;">
            <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">Clip</label>
            <select id="shotEditClip" class="modal-input">
              <!-- Populated dynamically -->
            </select>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
            <div>
              <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">Shot X (0-100)</label>
              <input type="number" id="shotEditX" class="modal-input" min="0" max="100" step="0.1">
            </div>
            <div>
              <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">Shot Y (0-100)</label>
              <input type="number" id="shotEditY" class="modal-input" min="0" max="100" step="0.1">
            </div>
          </div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; margin: 1rem 0;">
            <div>
              <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">Designation</label>
              <select id="shotEditDesignation" class="modal-input">
                <option value="Blue">Blue</option>
                <option value="Green">Green</option>
                <option value="Black">Black</option>
              </select>
            </div>
            <div>
              <label style="display: block; margin-bottom: 0.5rem; font-size: 0.875rem; color: var(--text-muted);">Result</label>
              <select id="shotEditResult" class="modal-input">
                <option value="Made">Made</option>
                <option value="Missed">Missed</option>
              </select>
            </div>
          </div>
          <div class="modal-btns">
            <button id="shotEditDelete" class="modal-btn secondary" style="background: var(--ou-crimson); color: white;">Delete Shot</button>
            <div style="flex: 1;"></div>
            <button id="shotEditCancel" class="modal-btn secondary">Cancel</button>
            <button id="shotEditSave" class="modal-btn primary">Save</button>
          </div>
        </div>
      </div>

      <div class="section-header">
        <h2 class="section-title" id="clipsTitle">All Clips</h2>
        <div class="view-toggle">
          <button class="view-btn active">Grid</button>
          <button class="view-btn">List</button>
        </div>
      </div>

      <div class="active-filters" id="activeFilters"></div>

      <div class="clips-grid" id="clipsGrid">
        <!-- Clips will be populated here -->
      </div>

      <!-- Spreadsheet List View -->
      <div class="spreadsheet-view" id="spreadsheetView">
        <div class="spreadsheet-wrapper">
          <table class="spreadsheet-table">
            <thead>
              <tr>
                <th>#</th>
                <th>Game</th>
                <th>Opponent</th>
                <th>Q</th>
                <th>Poss</th>
                <th>Situation</th>
                <th>Formation</th>
                <th>Play Name</th>
                <th>Scout Coverage</th>
                <th>Action Trigger</th>
                <th>Action Types</th>
                <th>Action Sequence</th>
                <th>Coverage</th>
                <th>Ball Screen</th>
                <th>Off-Ball Screen</th>
                <th>Help/Rotation</th>
                <th>Disruption</th>
                <th>Breakdown</th>
                <th>Result</th>
                <th>Paint Touch</th>
                <th>Shooter</th>
                <th>Shot Location</th>
                <th>Contest</th>
                <th>Rebound</th>
                <th>Pts</th>
                <th>Notes</th>
              </tr>
            </thead>
            <tbody id="spreadsheetBody">
              <!-- Rows will be inserted here -->
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- Filter Panel -->
  <div class="filter-panel" id="filterPanel">
    <div class="filter-panel-header">
      <h3 class="filter-panel-title">Clip Filters</h3>
      <button class="close-btn" id="closePanel">√ó</button>
    </div>
    <div class="filter-panel-content">
      <!-- Game Scope -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üéØ GAME SCOPE</div>
        <div class="checkbox-group" id="gameCheckboxes">
          <!-- Will be populated -->
        </div>
      </div>

      <!-- Situation -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üèÉ SITUATION</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="sit-halfcourt" value="Half Court" data-filter="situation">
            <label for="sit-halfcourt">Half Court</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="sit-transition" value="Transition" data-filter="situation">
            <label for="sit-transition">Transition</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="sit-slob" value="SLOB" data-filter="situation">
            <label for="sit-slob">SLOB</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="sit-blob" value="BLOB" data-filter="situation">
            <label for="sit-blob">BLOB</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="sit-early" value="Early Offense" data-filter="situation">
            <label for="sit-early">Early Offense</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="sit-ato" value="Half Court (ATO)" data-filter="situation">
            <label for="sit-ato">Half Court (ATO)</label>
          </div>
        </div>
      </div>

      <!-- Covered in Scout -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üìã COVERED IN SCOUT?</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="scout-yes" value="Yes ‚Äì Practiced" data-filter="scout">
            <label for="scout-yes">Yes ‚Äì Practiced</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="scout-partial" value="Partial ‚Äì Similar Action" data-filter="scout">
            <label for="scout-partial">Partial ‚Äì Similar Action</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="scout-no" value="No ‚Äì Not Practiced" data-filter="scout">
            <label for="scout-no">No ‚Äì Not Practiced</label>
          </div>
        </div>
      </div>

      <!-- Defensive Coverage -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üõ°Ô∏è DEFENSIVE COVERAGE</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="cov-man" value="Man" data-filter="coverage">
            <label for="cov-man">Man</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="cov-2-3" value="2-3" data-filter="coverage">
            <label for="cov-2-3">2-3</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="cov-3-2" value="3-2" data-filter="coverage">
            <label for="cov-3-2">3-2</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="cov-1-3-1" value="1-3-1" data-filter="coverage">
            <label for="cov-1-3-1">1-3-1</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="cov-1-2-2" value="1-2-2" data-filter="coverage">
            <label for="cov-1-2-2">1-2-2</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="cov-fullcourt" value="Full Court Man" data-filter="coverage">
            <label for="cov-fullcourt">Full Court Man</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="cov-2-2-1" value="2-2-1 Press" data-filter="coverage">
            <label for="cov-2-2-1">2-2-1 Press</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="cov-1-2-1-1" value="1-2-1-1 Press (Diamond)" data-filter="coverage">
            <label for="cov-1-2-1-1">1-2-1-1 Press (Diamond)</label>
          </div>
        </div>
      </div>

      <!-- Ball Screen Coverage -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üéØ BALL SCREEN COVERAGE</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="ball-under" value="Under" data-filter="ballScreen">
            <label for="ball-under">Under</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="ball-over" value="Over" data-filter="ballScreen">
            <label for="ball-over">Over</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="ball-ice" value="ICE" data-filter="ballScreen">
            <label for="ball-ice">ICE</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="ball-weak" value="Weak (Force Weak Hand)" data-filter="ballScreen">
            <label for="ball-weak">Weak (Force Weak Hand)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="ball-switch" value="Switch" data-filter="ballScreen">
            <label for="ball-switch">Switch</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="ball-hardhedge" value="Hard Hedge" data-filter="ballScreen">
            <label for="ball-hardhedge">Hard Hedge</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="ball-softhedge" value="Soft Hedge/Show" data-filter="ballScreen">
            <label for="ball-softhedge">Soft Hedge/Show</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="ball-peel" value="Peel Switch" data-filter="ballScreen">
            <label for="ball-peel">Peel Switch</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="ball-blitz" value="Blitz (Trap)" data-filter="ballScreen">
            <label for="ball-blitz">Blitz (Trap)</label>
          </div>
        </div>
      </div>

      <!-- Off-Ball Screen Coverage -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üéØ OFF-BALL SCREEN COVERAGE</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="off-attach" value="Attach/Stay" data-filter="offBall">
            <label for="off-attach">Attach/Stay</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="off-over" value="Over" data-filter="offBall">
            <label for="off-over">Over</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="off-under" value="Under" data-filter="offBall">
            <label for="off-under">Under</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="off-toplock" value="Top-Lock" data-filter="offBall">
            <label for="off-toplock">Top-Lock</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="off-switch" value="Switch" data-filter="offBall">
            <label for="off-switch">Switch</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="off-show" value="Show" data-filter="offBall">
            <label for="off-show">Show</label>
          </div>
        </div>
      </div>

      <!-- Help / Rotation -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üåÄ HELP / ROTATION</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="help-none" value="No Help / No Rotation" data-filter="help">
            <label for="help-none">No Help / No Rotation</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="help-lowman" value="Low-Man Help" data-filter="help">
            <label for="help-lowman">Low-Man Help</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="help-xout" value="X-Out Rotation" data-filter="help">
            <label for="help-xout">X-Out Rotation</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="help-sink" value="Sink / Fill" data-filter="help">
            <label for="help-sink">Sink / Fill</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="help-full" value="Full Rotation" data-filter="help">
            <label for="help-full">Full Rotation</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="help-late" value="Late Help" data-filter="help">
            <label for="help-late">Late Help</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="help-missed" value="No Rotation (Missed)" data-filter="help">
            <label for="help-missed">No Rotation (Missed)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="help-peel" value="Peel Help" data-filter="help">
            <label for="help-peel">Peel Help</label>
          </div>
        </div>
      </div>

      <!-- Defensive Disruption -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üí• DEFENSIVE DISRUPTION</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="disrupt-denywing" value="Denied Wing Entry" data-filter="disruption">
            <label for="disrupt-denywing">Denied Wing Entry</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="disrupt-denypost" value="Denied Post Entry" data-filter="disruption">
            <label for="disrupt-denypost">Denied Post Entry</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="disrupt-pressure" value="Pressured Ball Handler to Prevent Pass" data-filter="disruption">
            <label for="disrupt-pressure">Pressured Ball Handler to Prevent Pass</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="disrupt-deflect" value="Deflected Pass" data-filter="disruption">
            <label for="disrupt-deflect">Deflected Pass</label>
          </div>
        </div>
      </div>

      <!-- Breakdown -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">‚ö†Ô∏è BREAKDOWN</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="brkdwn-yes" value="Yes" data-filter="breakdown">
            <label for="brkdwn-yes">Yes</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="brkdwn-no" value="No" data-filter="breakdown">
            <label for="brkdwn-no">No</label>
          </div>
        </div>
      </div>

      <!-- Shooter Designation -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üéØ SHOOTER DESIGNATION</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="shoot-blue" value="Blue" data-filter="shooter">
            <label for="shoot-blue">üîµ Blue (Primary)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shoot-green" value="Green" data-filter="shooter">
            <label for="shoot-green">üü¢ Green (Shooter)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shoot-black" value="Black" data-filter="shooter">
            <label for="shoot-black">‚ö´ Black (Role)</label>
          </div>
        </div>
      </div>

      <!-- Play Result -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üìä PLAY RESULT</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="result-made" value="Made FG" data-filter="result">
            <label for="result-made">Made FG</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-missed" value="Missed FG" data-filter="result">
            <label for="result-missed">Missed FG</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-andone" value="And-One" data-filter="result">
            <label for="result-andone">And-One</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-liveTO" value="Live-Ball Turnover" data-filter="result">
            <label for="result-liveTO">Live-Ball Turnover</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-deadTO" value="Dead-Ball Turnover" data-filter="result">
            <label for="result-deadTO">Dead-Ball Turnover</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-shotclock" value="Turnover (Shot Clock Violation)" data-filter="result">
            <label for="result-shotclock">Turnover (Shot Clock Violation)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-shooting" value="Shooting Foul" data-filter="result">
            <label for="result-shooting">Shooting Foul</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-offball" value="Off-Ball Foul" data-filter="result">
            <label for="result-offball">Off-Ball Foul</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-reachIn" value="Reach-In Foul" data-filter="result">
            <label for="result-reachIn">Reach-In Foul</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-looseBall" value="Loose-Ball Foul" data-filter="result">
            <label for="result-looseBall">Loose-Ball Foul</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="result-deflection" value="Deflection (Out of Bounds)" data-filter="result">
            <label for="result-deflection">Deflection (Out of Bounds)</label>
          </div>
        </div>
      </div>

      <!-- Paint Touches -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üéØ PAINT TOUCHES</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="paint-none" value="No Paint Touch" data-filter="paintTouches">
            <label for="paint-none">No Paint Touch</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="paint-baseline" value="Drive Baseline" data-filter="paintTouches">
            <label for="paint-baseline">Drive Baseline</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="paint-middle" value="Drive Middle" data-filter="paintTouches">
            <label for="paint-middle">Drive Middle</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="paint-low" value="Post Touch - Low Block" data-filter="paintTouches">
            <label for="paint-low">Post Touch - Low Block</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="paint-high" value="Post Touch - High Post" data-filter="paintTouches">
            <label for="paint-high">Post Touch - High Post</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="paint-cut" value="Cut to Paint (Received Pass)" data-filter="paintTouches">
            <label for="paint-cut">Cut to Paint (Received Pass)</label>
          </div>
        </div>
      </div>

      <!-- Shot Location -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üéØ SHOT LOCATION</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="shot-rim" value="At Rim (0‚Äì4 ft)" data-filter="shotLocation">
            <label for="shot-rim">At Rim (0‚Äì4 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shot-paint" value="Paint (5‚Äì10 ft)" data-filter="shotLocation">
            <label for="shot-paint">Paint (5‚Äì10 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shot-short" value="Short Midrange (11‚Äì14 ft)" data-filter="shotLocation">
            <label for="shot-short">Short Midrange (11‚Äì14 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shot-long" value="Long Midrange (15‚Äì20 ft)" data-filter="shotLocation">
            <label for="shot-long">Long Midrange (15‚Äì20 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shot-corner" value="Corner 3 (21 ft 6 in)" data-filter="shotLocation">
            <label for="shot-corner">Corner 3 (21 ft 6 in)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shot-wing" value="Wing/Top 3 (22‚Äì23 ft)" data-filter="shotLocation">
            <label for="shot-wing">Wing/Top 3 (22‚Äì23 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shot-deep" value="Deep 3 (24‚Äì26 ft)" data-filter="shotLocation">
            <label for="shot-deep">Deep 3 (24‚Äì26 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="shot-late" value="Late Clock / Heave (27 ft +)" data-filter="shotLocation">
            <label for="shot-late">Late Clock / Heave (27 ft +)</label>
          </div>
        </div>
      </div>

      <!-- Shot Contest -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üõ°Ô∏è SHOT CONTEST</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="contest-open" value="Open (4+ ft)" data-filter="shotContest">
            <label for="contest-open">Open (4+ ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="contest-light" value="Light Contest / Late High-Hand (2‚Äì4 ft)" data-filter="shotContest">
            <label for="contest-light">Light Contest / Late High-Hand (2‚Äì4 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="contest-on-time" value="Contested/On-Time High-Hand (1‚Äì2 ft)" data-filter="shotContest">
            <label for="contest-on-time">Contested/On-Time High-Hand (1‚Äì2 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="contest-heavy" value="Heavy Contest / Early High-Hand (0‚Äì1 ft)" data-filter="shotContest">
            <label for="contest-heavy">Heavy Contest / Early High-Hand (0‚Äì1 ft)</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="contest-blocked" value="Blocked" data-filter="shotContest">
            <label for="contest-blocked">Blocked</label>
          </div>
        </div>
      </div>

      <!-- Rebound Outcome -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üèÄ REBOUND OUTCOME</div>
        <div class="checkbox-group">
          <div class="checkbox-item">
            <input type="checkbox" id="rebound-dreb" value="DREB" data-filter="rebound">
            <label for="rebound-dreb">DREB</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="rebound-oreb" value="OREB" data-filter="rebound">
            <label for="rebound-oreb">OREB</label>
          </div>
          <div class="checkbox-item">
            <input type="checkbox" id="rebound-other" value="Other" data-filter="rebound">
            <label for="rebound-other">Other</label>
          </div>
        </div>
      </div>

      <!-- Text Search Filters -->
      <div class="filter-group collapsed" data-filter-section>
        <div class="filter-group-title">üîç TAG SEARCH</div>
        <div class="filter-search-group">
          <div class="filter-search-field">
            <label for="search-formation">Offensive Formation</label>
            <input type="search" id="search-formation" data-filter-search="formation" placeholder="e.g. Horns, 5-Out" list="search-formation-options" autocomplete="off">
            <datalist id="search-formation-options"></datalist>
          </div>
          <div class="filter-search-field">
            <label for="search-playname">Play Name</label>
            <input type="search" id="search-playname" data-filter-search="playName" placeholder="Type play name" list="search-playname-options" autocomplete="off">
            <datalist id="search-playname-options"></datalist>
          </div>
          <div class="filter-search-field">
            <label for="search-actiontrigger">Action Trigger</label>
            <input type="search" id="search-actiontrigger" data-filter-search="actionTrigger" placeholder="e.g. Entry, DHO" list="search-actiontrigger-options" autocomplete="off">
            <datalist id="search-actiontrigger-options"></datalist>
          </div>
          <div class="filter-search-field">
            <label for="search-actiontypes">Action Type(s)</label>
            <input type="search" id="search-actiontypes" data-filter-search="actionTypes" placeholder="Comma-separated actions" list="search-actiontypes-options" autocomplete="off">
            <datalist id="search-actiontypes-options"></datalist>
          </div>
          <div class="filter-search-field">
            <label for="search-actionsequence">Action Sequence</label>
            <input type="search" id="search-actionsequence" data-filter-search="actionSequence" placeholder="Sequence keywords" list="search-actionsequence-options" autocomplete="off">
            <datalist id="search-actionsequence-options"></datalist>
          </div>
          <div class="filter-search-field">
            <label for="search-breakdown">Defensive Breakdown Detail</label>
            <input type="search" id="search-breakdown" data-filter-search="breakdownDetail" placeholder="Search breakdown notes" list="search-breakdown-options" autocomplete="off">
            <datalist id="search-breakdown-options"></datalist>
          </div>
        </div>
      </div>
    </div>
    <div class="filter-panel-footer">
      <button class="btn btn-clear" id="clearFilters">Clear All</button>
      <button class="btn btn-apply" id="applyFilters">Apply Filters (<span id="filterCount">0</span>)</button>
    </div>
  </div>

  <!-- Overlay -->
  <div class="overlay" id="overlay"></div>

  <script>
    const API_URL = 'http://127.0.0.1:8000';
    const LocationAPI = window.LocationUtils || {};
    const LOCATION_MAP_KEY = LocationAPI.LOCATION_MAP_KEY || 'ou_wbb_game_location_map';
    const standardizeLocation = LocationAPI.standardizeLocation || function (value) {
      const raw = cleanString(value, '').toLowerCase();
      if (!raw) return '';
      if (raw.includes('neutral')) return 'neutral';
      if (raw === 'away' || raw.includes('away') || raw === 'road' || raw.includes('road')) return 'away';
      if (raw === 'home' || raw.includes('home')) return 'home';
      return raw;
    };
    const formatLocationLabel = LocationAPI.formatLocationLabel || function (code) {
      const normalized = standardizeLocation(code);
      if (normalized === 'home') return 'HOME';
      if (normalized === 'away') return 'AWAY';
      if (normalized === 'neutral') return 'NEUTRAL';
      return normalized ? normalized.toUpperCase() : '‚Äî';
    };
    let games = [];
    let clips = [];
    let masterClips = [];
    let currentViewClips = [];
    const TEXT_SEARCH_FIELDS = [
      { key: 'formation', label: 'Formation', accessor: clip => cleanString(clip.formation), datalistId: 'search-formation-options' },
      { key: 'playName', label: 'Play Name', accessor: clip => cleanString(clip.playName), datalistId: 'search-playname-options' },
      { key: 'actionTrigger', label: 'Action Trigger', accessor: clip => cleanString(clip.actionTrigger), datalistId: 'search-actiontrigger-options' },
      { key: 'actionTypes', label: 'Action Type(s)', accessor: clip => cleanString(clip.actionTypes), datalistId: 'search-actiontypes-options' },
      { key: 'actionSequence', label: 'Action Sequence', accessor: clip => cleanString(clip.actionSequence), datalistId: 'search-actionsequence-options' },
      { key: 'breakdownDetail', label: 'Breakdown Detail', accessor: clip => cleanString(clip.breakdownDetail || clip.breakdown), datalistId: 'search-breakdown-options' }
    ];
    const cleanString = (value, fallback = '') => {
      if (value === undefined || value === null || value === '') return (fallback ?? '').toString().trim();
      return value.toString().trim();
    };
    const tidy = value => cleanString(value);

    const escapeHtml = value => cleanString(value).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');

    const encodeAttr = value => cleanString(value).replace(/"/g, '&quot;');
    const slugifyString = value => cleanString(value).toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '');
    const loadCachedLocations = () => {
      try {
        return JSON.parse(localStorage.getItem(LOCATION_MAP_KEY) || '{}');
      } catch (err) {
        console.warn('Unable to read cached locations', err);
        return {};
      }
    };
    const cachedLocations = loadCachedLocations();
    const resolveCachedLocation = (clip) => {
      if (LocationAPI.resolveCachedLocation) {
        const resolved = LocationAPI.resolveCachedLocation(clip);
        if (resolved && (resolved.code || resolved.display)) return resolved;
      }
      const possibleKeys = [
        clip.gameId,
        clip.game_id,
        clip.__gameId,
        clip.game_num,
        clip.gameNum,
        clip.gameNumber,
        `num:${clip.game_num ?? clip.gameId ?? ''}`,
        `num:${clip.game_num ?? clip.gameId ?? ''}:${slugifyString(clip.opponent)}`
      ];
      for (const key of possibleKeys) {
        if (!key) continue;
        const payload = cachedLocations[String(key)];
        if (payload && (payload.code || payload.display)) return payload;
      }
      return null;
    };

    function normalizeLocationCode(value) {
      return standardizeLocation(value);
    }

    function getOpponentForClip(clip) {
      if (!clip) return '‚Äî';
      const primary = cleanString(clip.game || clip.opponent, '');
      if (primary && primary !== '‚Äî' && primary.toLowerCase() !== 'opponent') return primary;
      const secondary = cleanString(clip.opponent, '');
      if (secondary && secondary !== '‚Äî' && secondary.toLowerCase() !== 'opponent') return secondary;
      const clipGameKey = cleanString(clip.gameId ?? clip.game_id ?? clip.gameNum, '');
      if (clipGameKey && Array.isArray(games) && games.length) {
        const gameRecord = games.find(g => cleanString(g.id, '') === clipGameKey);
        if (gameRecord) {
          const fromGame = cleanString(gameRecord.opponent, '');
          if (fromGame && fromGame !== '‚Äî' && fromGame.toLowerCase() !== 'opponent') return fromGame;
        }
      }
      return '‚Äî';
    }

    function normalizeClip(clip) {
      const coverage = cleanString(clip.defensive_coverage, 'Man');
      const ballScreen = cleanString(clip.ball_screen_coverage, 'N/A');
      const offBall = cleanString(clip.offball_screen_coverage, 'N/A');
      const help = cleanString(clip.help_rotation, 'No Help / No Rotation');
      const disruption = cleanString(clip.defensive_disruption, 'None');
      const breakdownDetail = cleanString(clip.defensive_breakdown, '');
      const breakdown = breakdownDetail.toLowerCase().startsWith('y') ? 'Yes' : 'No';
      const shooter = cleanString(clip.shooter_designation, 'Blue');
      const result = cleanString(clip.play_result, 'Missed FG');
      const paintTouch = cleanString(clip.paint_touches, 'No Paint Touch');
      const shotLocation = cleanString(clip.shot_location, '‚Äî');
      const shotContest = cleanString(clip.shot_contest, '‚Äî');
      const rebound = cleanString(clip.rebound_outcome, 'Other');
      const videoPath = clip.filename ? `${API_URL}/clips/${clip.filename}` : '';
      const gameMeta = (clip.game && typeof clip.game === 'object') ? clip.game : null;
      const gameId = clip.game_num ?? clip.gameId ?? clip.game_id ?? gameMeta?.id ?? gameMeta?.game_num ?? '‚Äî';
      const opponentName = cleanString(
        clip.opponent ??
        gameMeta?.opponent ??
        gameMeta?.opponentName ??
        gameMeta?.opponent_name,
        ''
      );
      const gameLabel = opponentName || '‚Äî';
      const cachedLocation = resolveCachedLocation(clip);
      const rawLocation =
        clip.location_code ??
        clip.locationCode ??
        clip.__location ??
        clip.game_location ??
        clip.gameLocation ??
        gameMeta?.location ??
        clip.location ??
        clip.location_display ??
        clip.locationDisplay ??
        clip.Location ??
        clip['Game Location'];
      const rawDisplay =
        clip.location_display ??
        clip.locationDisplay ??
        clip.Location ??
        clip['Game Location'] ??
        clip.game_location ??
        clip.gameLocation ??
        clip.location ??
        '';
      let locationCode = normalizeLocationCode(rawLocation || rawDisplay || (cachedLocation?.code ?? ''));
      let locationDisplay = cleanString(rawDisplay, '') || cachedLocation?.display || formatLocationLabel(locationCode);
      if (!locationCode && cachedLocation?.code) {
        locationCode = cachedLocation.code;
        locationDisplay = cachedLocation.display || formatLocationLabel(locationCode);
      }
      const scoreValue = cleanString(clip.score ?? gameMeta?.score, '‚Äî');
      const resultOutcome = cleanString(clip.result ?? gameMeta?.result, '');
      const pointsValue = Number.parseFloat(clip.points);
      const normalizedPoints = Number.isFinite(pointsValue) ? pointsValue : 0;

      return {
        id: clip.id,
        gameId,
        game: gameLabel,
        quarter: clip.quarter,
        possession: clip.possession,
        situation: cleanString(clip.situation, 'Half Court'),
        formation: cleanString(clip.offensive_formation, '‚Äî'),
        playName: cleanString(clip.play_name, 'Defensive Possession'),
        scoutCoverage: cleanString(clip.scout_coverage, 'No ‚Äì Not Practiced'),
        actionTrigger: cleanString(clip.action_trigger, '‚Äî'),
        actionTypes: cleanString(clip.action_types, '‚Äî'),
        actionSequence: cleanString(clip.action_sequence, '‚Äî'),
        coverage,
        defensiveCoverage: coverage,
        ballScreen,
        ballScreenCoverage: ballScreen,
        offBallScreen: offBall,
        offBallScreenCoverage: offBall,
        helpRotation: help,
        defensiveDisruption: disruption,
        disruption,
        breakdownDetail,
        breakdown,
        shooter,
        shooterDesignation: shooter,
        shooter_designation: shooter,
        result,
        paintTouch,
        paintTouches: paintTouch,
        shotLocation,
        shotContest,
        contest: shotContest,
        rebound,
        reboundOutcome: rebound,
        points: normalizedPoints,
        has_shot: cleanString(clip.has_shot, 'No'),
        shot_x: cleanString(clip.shot_x, ''),
        shot_y: cleanString(clip.shot_y, ''),
        shot_result: cleanString(clip.shot_result, ''),
        play_name: cleanString(clip.play_name, 'Defensive Possession'),
        shot_contest: shotContest,
        opponent: opponentName,
        notes: cleanString(clip.notes, ''),
        videoPath,
        filename: clip.filename,
        startTime: clip.start_time || '',
        endTime: clip.end_time || '',
        location: locationCode,
        locationDisplay,
        Location: locationDisplay,
        location_code: locationCode,
        location_display: locationDisplay,
        score: scoreValue,
        resultOutcome
      };
    }

    // Load real clips from API
    async function loadClipsFromAPI() {
      try {
        const response = await fetch(`${API_URL}/api/clips`);
        const apiClips = await response.json();

        // Transform API data to match expected format
        clips = apiClips.map(normalizeClip);
        masterClips = clips.slice();
        currentViewClips = clips.slice();

        // Group clips by game
        const gameMap = {};
        clips.forEach(clip => {
          if (!gameMap[clip.gameId]) {
            gameMap[clip.gameId] = {
              id: clip.gameId,
              opponent: clip.game,
              location: '',
              locationDisplay: '',
              locationCounts: {},
              score: clip.score || '‚Äî',
              result: clip.resultOutcome || '',
              clips: 0,
              stopRate: 0,
              breakdownRate: 0
            };
          }
          const gameEntry = gameMap[clip.gameId];
          const clipOpponentLabel = cleanString(clip.game, '');
          const currentOpponentLabel = cleanString(gameEntry.opponent, '');
          if ((!currentOpponentLabel || currentOpponentLabel === '‚Äî') && clipOpponentLabel && clipOpponentLabel !== '‚Äî') {
            gameEntry.opponent = clipOpponentLabel;
          }
          // Track location counts to find the mode
          const rawLocationCandidate =
            clip.location ??
            clip.location_code ??
            clip.locationCode ??
            clip.Location ??
            clip.location_display ??
            clip.locationDisplay ??
            clip['Location'] ??
            clip['Game Location'];
          let clipLocation = normalizeLocationCode(rawLocationCandidate);
          const cached = resolveCachedLocation(clip);
          if (!clipLocation && cached?.code) {
            clipLocation = cached.code;
          }
          const clipLocationDisplay = cleanString(
            clip.locationDisplay ??
            clip.location_display ??
            clip.Location ??
            clip['Location'] ??
            clip['Game Location'] ??
            cached?.display ??
            formatLocationLabel(clipLocation),
            ''
          );
          if (clipLocation) {
            gameEntry.locationCounts[clipLocation] = (gameEntry.locationCounts[clipLocation] || 0) + 1;
            if (!gameEntry.location) gameEntry.location = clipLocation;
            if (!gameEntry.locationDisplay) gameEntry.locationDisplay = clipLocationDisplay || formatLocationLabel(clipLocation);
          } else if (clipLocationDisplay) {
            const inferredCode = normalizeLocationCode(clipLocationDisplay);
            if (inferredCode) {
              gameEntry.locationCounts[inferredCode] = (gameEntry.locationCounts[inferredCode] || 0) + 1;
              if (!gameEntry.location) gameEntry.location = inferredCode;
            }
            gameEntry.locationDisplay = clipLocationDisplay;
          }
          gameEntry.clips++;
          const clipPoints = Number(clip.points);
          if ((Number.isFinite(clipPoints) && clipPoints === 0) || clip.result.includes('Turnover') || clip.result.includes('Missed')) {
            gameEntry.stopRate++;
          }
          if (clip.breakdown && clip.breakdown.toLowerCase().includes('yes')) {
            gameEntry.breakdownRate++;
          }
        });

        // Calculate mode (most common) location for each game
        Object.values(gameMap).forEach(game => {
          if (Object.keys(game.locationCounts).length > 0) {
            // Find the location with the highest count
            let modeLocation = '';
            let maxCount = 0;
            for (const [loc, count] of Object.entries(game.locationCounts)) {
              if (count > maxCount) {
                maxCount = count;
                modeLocation = loc;
              }
            }
            game.location = modeLocation;
            game.locationDisplay = formatLocationLabel(modeLocation);
          }

          if ((!game.location || game.location === '‚Äî' || game.location === '-') || !cleanString(game.locationDisplay)) {
            const cached = resolveCachedLocation({
              gameId: game.id,
              game_id: game.id,
              game_num: game.id,
              opponent: game.opponent
            }) || null;
            if (cached?.code) {
              game.location = cached.code;
              game.locationDisplay = cached.display || formatLocationLabel(cached.code);
            } else if (cached?.display && !game.locationDisplay) {
              game.locationDisplay = cached.display;
              game.location = normalizeLocationCode(cached.display);
            }
          }
        });

        games = Object.values(gameMap).map(game => ({
          ...game,
          location: game.location,
          locationDisplay: game.locationDisplay || formatLocationLabel(game.location),
          locationLabel: game.locationDisplay || formatLocationLabel(game.location),
          stopRate: game.clips ? Math.round((game.stopRate / game.clips) * 100) : 0,
          breakdownRate: game.clips ? Math.round((game.breakdownRate / game.clips) * 100) : 0
        }));

        // Initialize UI
        renderGames(getGamesForActiveView());
        refreshSearchOptions();
        refreshGameCheckboxes();
        updateStatsBar(clips);

      } catch (error) {
        console.error('Error loading clips:', error);
        alert('Could not load clips. Make sure media_server.py is running.');
      }
    }

    // Reload just the clips data without resetting UI
    async function reloadClipsData() {
      try {
        const response = await fetch(`${API_URL}/api/clips`);
        if (!response.ok) throw new Error('Failed to fetch clips');

        const apiClips = await response.json();

        // Transform API data to match expected format
        clips = apiClips.map(normalizeClip);
        masterClips = clips.slice();
        currentViewClips = clips.slice();
      } catch (error) {
        console.error('Error reloading clips:', error);
        throw error;
      }
    }

    // Load clips on page load
    loadClipsFromAPI();

    // Render games
    function renderGames(list = games) {
      const gamesGrid = document.getElementById('gamesGrid');
      if (!gamesGrid) return;
      gamesGrid.innerHTML = list.map(game => `
        <div class="game-card" data-game-id="${game.id}">
          <div class="game-header">
            <div class="game-number">Game ${game.id}</div>
            <div class="game-opponent">
              vs ${escapeHtml(game.opponent)}
              <span class="location-badge">${escapeHtml(game.locationLabel || formatLocationLabel(game.location))}</span>
            </div>
            <div class="game-score ${game.result === 'W' ? 'score-win' : 'score-loss'}">
              ${escapeHtml(game.score)} ${escapeHtml(game.result)}
            </div>
          </div>
          <div class="game-stats">
            <div class="game-stat">
              <div class="game-stat-value">${game.clips}</div>
              <div class="game-stat-label">Clips</div>
            </div>
            <div class="game-stat">
              <div class="game-stat-value">${game.stopRate}%</div>
              <div class="game-stat-label">Stop Rate</div>
            </div>
            <div class="game-stat">
              <div class="game-stat-value">${game.breakdownRate}%</div>
              <div class="game-stat-label">Breakdown</div>
            </div>
          </div>
        </div>
      `).join('');
    }
    // Render clips
    function renderClips(clipsToShow) {
      const clipsGrid = document.getElementById('clipsGrid');
      if (!clipsGrid) return;
      currentViewClips = clipsToShow.slice();
      clipsGrid.innerHTML = clipsToShow.map(clip => `
        <div class="clip-card" data-clip-id="${clip.id}">
          <div class="clip-thumbnail">
            <video preload="metadata">
              <source src="${clip.videoPath}#t=0.5" type="video/mp4">
            </video>
            <div class="play-overlay">
              <div class="play-icon"></div>
            </div>
            <div class="clip-badges">
              <span class="badge badge-quarter">Q${clip.quarter} P${clip.possession}</span>
            </div>
          </div>
          <div class="clip-info">
            <div class="clip-game">G${clip.gameId} ${escapeHtml(clip.game)}</div>
            <div class="clip-play">${escapeHtml(clip.playName)}</div>
            <div class="clip-tags">
              ${clip.breakdown === 'Yes' ? '<span class="tag tag-breakdown">üî¥ Breakdown</span>' : '<span class="tag tag-stop">üü¢ Stop</span>'}
              <span class="tag tag-${clip.shooter.toLowerCase()}">${clip.shooter === 'Blue' ? 'üîµ' : clip.shooter === 'Green' ? 'üü¢' : '‚ö´'} ${clip.shooter}</span>
              <span class="tag tag-points">${clip.points} pts</span>
            </div>
          </div>
        </div>
      `).join('');
    }

    // Show game clips
    function showGameClips(gameId) {
      const game = games.find(g => g.id === gameId);
      if (!game) return;
      const gameClips = clips.filter(c => c.gameId === gameId);
      currentViewClips = gameClips.slice();
      document.getElementById('gamesGrid').style.display = 'none';
      document.getElementById('clipsSection').classList.remove('hidden');
      document.getElementById('clipsTitle').textContent = `Game ${game.id} vs ${escapeHtml(game.opponent)} ‚Äî ${gameClips.length} Clips`;

      renderClips(gameClips);
      const spreadsheetView = document.getElementById('spreadsheetView');
      const clipsGrid = document.getElementById('clipsGrid');
      if (spreadsheetView && clipsGrid) {
        if (spreadsheetView.classList.contains('active')) {
          clipsGrid.style.display = 'none';
          populateSpreadsheet();
        } else {
          clipsGrid.style.display = 'grid';
          spreadsheetView.classList.remove('active');
        }
      }

      // Render shot chart for this game
      renderShotChart(gameClips, game.opponent);

      // Update stats
      updateStatsBar(gameClips);

      // Scroll to top
      window.scrollTo(0, 0);
    }

    function deriveStatsMetrics(dataset) {
      const stats = {
        games: 0,
        clips: 0,
        stopRate: null,
        breakdownRate: null,
        ppp: null
      };
      if (!Array.isArray(dataset) || dataset.length === 0) {
        return stats;
      }
      const gameIds = new Set();
      let stopCount = 0;
      let breakdownCount = 0;
      let totalPoints = 0;

      dataset.forEach(clip => {
        if (!clip) return;
        const rawGameId = clip.gameId ?? clip.game_id ?? clip.game;
        if (rawGameId !== undefined && rawGameId !== null) {
          const id = cleanString(rawGameId, '');
          if (id) gameIds.add(id);
        }
        const breakdownValue = cleanString(clip.breakdown, '').toLowerCase();
        if (breakdownValue.startsWith('no')) {
          stopCount += 1;
        } else if (breakdownValue.startsWith('yes')) {
          breakdownCount += 1;
        }
        const clipPoints = Number(clip.points);
        if (!Number.isNaN(clipPoints)) {
          totalPoints += clipPoints;
        }
      });

      stats.games = gameIds.size;
      stats.clips = dataset.length;
      if (stats.clips > 0) {
        stats.stopRate = (stopCount / stats.clips) * 100;
        stats.breakdownRate = (breakdownCount / stats.clips) * 100;
        stats.ppp = totalPoints / stats.clips;
      }

      return stats;
    }

    // Update stats bar
    function updateStatsBar(clipsData) {
      const statsBar = document.getElementById('statsBar') || document.querySelector('.stats-bar');
      if (!statsBar) return;

      const dataset = Array.isArray(clipsData) ? clipsData : [];
      const stats = deriveStatsMetrics(dataset);
      const stopRateDisplay = stats.stopRate !== null ? `${Math.round(stats.stopRate)}%` : '‚Äî';
      const breakdownDisplay = stats.breakdownRate !== null ? `${Math.round(stats.breakdownRate)}%` : '‚Äî';
      const pppDisplay = stats.ppp !== null ? stats.ppp.toFixed(2) : '‚Äî';

      statsBar.innerHTML = `
        <div class="stat">
          <div class="stat-label">Total Games</div>
          <div class="stat-value">${stats.games}</div>
        </div>
        <div class="stat">
          <div class="stat-label">Total Clips</div>
          <div class="stat-value">${stats.clips}</div>
        </div>
        <div class="stat">
          <div class="stat-label">Stop Rate</div>
          <div class="stat-value">${stopRateDisplay}</div>
        </div>
        <div class="stat">
          <div class="stat-label">Breakdown %</div>
          <div class="stat-value">${breakdownDisplay}</div>
        </div>
        <div class="stat">
          <div class="stat-label">PPP Allowed</div>
          <div class="stat-value">${pppDisplay}</div>
        </div>
      `;
    }

    // Open clip detail (opens new page)
   function openClipDetail(clipId) {
  if (!clipId) return;
  window.location.href = `clip_detail2.html?id=${clipId}`;
    }

    // Filter panel
    document.getElementById('filterToggle').addEventListener('click', () => {
      document.getElementById('filterPanel').classList.add('open');
      document.getElementById('overlay').classList.add('active');
    });

    document.querySelectorAll('[data-filter-section] .filter-group-title').forEach(title => {
      title.addEventListener('click', () => {
        const group = title.parentElement;
        group.classList.toggle('collapsed');
      });
    });

    document.getElementById('closePanel').addEventListener('click', () => {
      document.getElementById('filterPanel').classList.remove('open');
      document.getElementById('overlay').classList.remove('active');
    });

    document.getElementById('overlay').addEventListener('click', () => {
      document.getElementById('filterPanel').classList.remove('open');
      document.getElementById('overlay').classList.remove('active');
    });

    // Initialize
    renderGames();

    // Populate game checkboxes in filter panel
function refreshGameCheckboxes() {
  const gameCheckboxes = document.getElementById('gameCheckboxes');
  if (!gameCheckboxes) return;
  gameCheckboxes.innerHTML = games.map(game => `
    <div class="checkbox-item">
      <input type="checkbox" id="game-${game.id}" value="${game.id}" data-filter="game">
      <label for="game-${game.id}">Game ${game.id} - ${game.opponent}</label>
    </div>
  `).join('');
  bindFilterCheckboxListeners();
  updateFilterCount();
}
refreshGameCheckboxes();

function refreshSearchOptions() {
  TEXT_SEARCH_FIELDS.forEach(field => {
    const datalist = document.getElementById(field.datalistId);
    if (!datalist) return;
    const map = new Map();
    masterClips.forEach(clip => {
      const value = tidy(field.accessor(clip));
      if (!value) return;
      const norm = value.toLowerCase();
      if (!map.has(norm)) map.set(norm, value);
    });
    field.optionLookup = map;
    const options = Array.from(map.values()).sort((a, b) => a.localeCompare(b, undefined, { sensitivity: 'base' }));
    datalist.innerHTML = options.map(opt => `<option value="${escapeHtml(opt)}"></option>`).join('');
  });
}

    // View toggles
    function getGamesForActiveView() {
      const activeViewBtn = document.querySelector('[data-view].active');
      if (!activeViewBtn) return games;
      const view = activeViewBtn.dataset.view;
      if (view === 'home') {
        return games.filter(g => g.location === 'home');
      }
      if (view === 'away') {
        return games.filter(g => g.location === 'away' || g.location === 'road');
      }
      if (view === 'neutral') {
        return games.filter(g => g.location === 'neutral');
      }
      return games;
    }

    document.querySelectorAll('[data-view]').forEach(btn => {
      btn.addEventListener('click', (event) => {
        document.querySelectorAll('[data-view]').forEach(b => b.classList.remove('active'));
        event.currentTarget.classList.add('active');

        renderGames(getGamesForActiveView());
      });
    });

    const gamesGridEl = document.getElementById('gamesGrid');
    if (gamesGridEl) {
      gamesGridEl.addEventListener('click', (event) => {
        const card = event.target.closest('.game-card');
        if (!card) return;
        const gameId = parseInt(card.dataset.gameId, 10);
        if (!Number.isNaN(gameId)) showGameClips(gameId);
      });
    }

    const clipsGridEl = document.getElementById('clipsGrid');
    if (clipsGridEl) {
      clipsGridEl.addEventListener('click', (event) => {
        const card = event.target.closest('.clip-card');
        if (!card) return;
        const clipId = card.dataset.clipId;
        if (clipId) openClipDetail(clipId);
      });
    }

    const spreadsheetBody = document.getElementById('spreadsheetBody');
    if (spreadsheetBody) {
      spreadsheetBody.addEventListener('click', (event) => {
        const row = event.target.closest('tr[data-clip-id]');
        if (!row) return;
        const clipId = row.dataset.clipId;
        if (clipId) openClipDetail(clipId);
      });
    }

    const activeFiltersRoot = document.getElementById('activeFilters');
    if (activeFiltersRoot) {
      activeFiltersRoot.addEventListener('click', (event) => {
        const removeBtn = event.target.closest('.remove-filter');
        if (!removeBtn) return;
        removeFilter(removeBtn.dataset.removeType, removeBtn.dataset.removeValue);
      });
    }

    const backButton = document.getElementById('backToGamesBtn');
    if (backButton) backButton.addEventListener('click', goBackToGames);

    const shotChartToggleEl = document.getElementById('shotChartToggle');
    if (shotChartToggleEl) shotChartToggleEl.addEventListener('click', toggleShotChart);

    // Apply filters
    document.getElementById('applyFilters').addEventListener('click', () => {
      const selectedGames = Array.from(document.querySelectorAll('[data-filter="game"]:checked')).map(cb => parseInt(cb.value, 10));
      const selectedSituations = Array.from(document.querySelectorAll('[data-filter="situation"]:checked')).map(cb => cb.value);
      const selectedScout = Array.from(document.querySelectorAll('[data-filter="scout"]:checked')).map(cb => cb.value);
      const selectedCoverages = Array.from(document.querySelectorAll('[data-filter="coverage"]:checked')).map(cb => cb.value);
      const selectedBallScreens = Array.from(document.querySelectorAll('[data-filter="ballScreen"]:checked')).map(cb => cb.value);
      const selectedOffBall = Array.from(document.querySelectorAll('[data-filter="offBall"]:checked')).map(cb => cb.value);
      const selectedHelp = Array.from(document.querySelectorAll('[data-filter="help"]:checked')).map(cb => cb.value);
      const selectedDisruptions = Array.from(document.querySelectorAll('[data-filter="disruption"]:checked')).map(cb => cb.value);
      const selectedBreakdowns = Array.from(document.querySelectorAll('[data-filter="breakdown"]:checked')).map(cb => cb.value);
      const selectedShooters = Array.from(document.querySelectorAll('[data-filter="shooter"]:checked')).map(cb => cb.value);
      const selectedResults = Array.from(document.querySelectorAll('[data-filter="result"]:checked')).map(cb => cb.value);
      const selectedPaintTouches = Array.from(document.querySelectorAll('[data-filter="paintTouches"]:checked')).map(cb => cb.value);
      const selectedShotLocations = Array.from(document.querySelectorAll('[data-filter="shotLocation"]:checked')).map(cb => cb.value);
      const selectedShotContests = Array.from(document.querySelectorAll('[data-filter="shotContest"]:checked')).map(cb => cb.value);
      const selectedRebounds = Array.from(document.querySelectorAll('[data-filter="rebound"]:checked')).map(cb => cb.value);
      const searchQueries = {};

      let filtered = clips;

      if (selectedGames.length > 0) {
        filtered = filtered.filter(c => selectedGames.includes(c.gameId));
      }
      if (selectedSituations.length > 0) {
        filtered = filtered.filter(c => selectedSituations.includes(cleanString(c.situation)));
      }
      if (selectedScout.length > 0) {
        filtered = filtered.filter(c => selectedScout.includes(cleanString(c.scoutCoverage)));
      }
      if (selectedCoverages.length > 0) {
        filtered = filtered.filter(c => selectedCoverages.includes(cleanString(c.coverage)));
      }
      if (selectedBallScreens.length > 0) {
        filtered = filtered.filter(c => selectedBallScreens.includes(cleanString(c.ballScreen)));
      }
      if (selectedOffBall.length > 0) {
        filtered = filtered.filter(c => selectedOffBall.includes(cleanString(c.offBallScreen)));
      }
      if (selectedHelp.length > 0) {
        filtered = filtered.filter(c => selectedHelp.includes(cleanString(c.helpRotation)));
      }
      if (selectedDisruptions.length > 0) {
        filtered = filtered.filter(c => selectedDisruptions.includes(cleanString(c.disruption)));
      }
      if (selectedBreakdowns.length > 0) {
        filtered = filtered.filter(c => selectedBreakdowns.includes(cleanString(c.breakdown)));
      }
      if (selectedShooters.length > 0) {
        filtered = filtered.filter(c => selectedShooters.includes(cleanString(c.shooter)));
      }
      if (selectedResults.length > 0) {
        filtered = filtered.filter(c => selectedResults.includes(cleanString(c.result)));
      }
      if (selectedPaintTouches.length > 0) {
        filtered = filtered.filter(c => selectedPaintTouches.includes(cleanString(c.paintTouch)));
      }
      if (selectedShotLocations.length > 0) {
        filtered = filtered.filter(c => selectedShotLocations.includes(cleanString(c.shotLocation)));
      }
      if (selectedShotContests.length > 0) {
        filtered = filtered.filter(c => selectedShotContests.includes(cleanString(c.contest)));
      }
      if (selectedRebounds.length > 0) {
        filtered = filtered.filter(c => selectedRebounds.includes(cleanString(c.rebound)));
      }

      TEXT_SEARCH_FIELDS.forEach(field => {
        const input = document.querySelector(`[data-filter-search="${field.key}"]`);
        const query = cleanString(input?.value || '');
        if (query) {
          const lookup = field.optionLookup || new Map();
          const canonical = lookup.get(query.toLowerCase()) || query;
          filtered = filtered.filter(c => field.accessor(c).toLowerCase() === canonical.toLowerCase());
          searchQueries[field.key] = canonical;
        }
      });

      currentViewClips = filtered.slice();
      document.getElementById('gamesGrid').style.display = 'none';
      document.getElementById('clipsSection').classList.remove('hidden');
      document.getElementById('clipsTitle').textContent = `Filtered Results ‚Äî ${filtered.length} Clips`;

      renderClips(filtered);

      // Render shot chart for filtered clips
      // Determine if we're filtering by a single game
      const uniqueGames = [...new Set(filtered.map(c => c.game))];
      const gameName = uniqueGames.length === 1 ? uniqueGames[0] : 'Filtered Results';
      renderShotChart(filtered, gameName);
      const spreadsheetView = document.getElementById('spreadsheetView');
      const clipsGrid = document.getElementById('clipsGrid');
      if (spreadsheetView && clipsGrid) {
        if (spreadsheetView.classList.contains('active')) {
          clipsGrid.style.display = 'none';
          populateSpreadsheet();
        } else {
          clipsGrid.style.display = 'grid';
          spreadsheetView.classList.remove('active');
        }
      }

      updateStatsBar(filtered);

      document.getElementById('filterPanel').classList.remove('open');
      document.getElementById('overlay').classList.remove('active');

      const activeFiltersDiv = document.getElementById('activeFilters');
      let filtersHTML = '';

      if (selectedGames.length > 0) {
        selectedGames.forEach(gid => {
          const game = games.find(g => g.id === gid);
          const opponentName = game ? game.opponent : 'Opponent';
          filtersHTML += `<div class="active-filter-chip"><span>Game ${gid} - ${escapeHtml(opponentName)}</span><span class="remove-filter" data-remove-type="game" data-remove-value="${gid}">√ó</span></div>`;
        });
      }
      selectedSituations.forEach(s => {
        filtersHTML += `<div class="active-filter-chip"><span>${escapeHtml(s)}</span><span class="remove-filter" data-remove-type="situation" data-remove-value="${encodeAttr(s)}">√ó</span></div>`;
      });
      selectedScout.forEach(s => {
        filtersHTML += `<div class="active-filter-chip"><span>Scout: ${escapeHtml(s)}</span><span class="remove-filter" data-remove-type="scout" data-remove-value="${encodeAttr(s)}">√ó</span></div>`;
      });
      selectedCoverages.forEach(cov => {
        filtersHTML += `<div class="active-filter-chip"><span>${escapeHtml(cov)}</span><span class="remove-filter" data-remove-type="coverage" data-remove-value="${encodeAttr(cov)}">√ó</span></div>`;
      });
      selectedBallScreens.forEach(bs => {
        filtersHTML += `<div class="active-filter-chip"><span>Ball Screen: ${escapeHtml(bs)}</span><span class="remove-filter" data-remove-type="ballScreen" data-remove-value="${encodeAttr(bs)}">√ó</span></div>`;
      });
      selectedOffBall.forEach(ob => {
        filtersHTML += `<div class="active-filter-chip"><span>Off-Ball: ${escapeHtml(ob)}</span><span class="remove-filter" data-remove-type="offBall" data-remove-value="${encodeAttr(ob)}">√ó</span></div>`;
      });
      selectedHelp.forEach(h => {
        filtersHTML += `<div class="active-filter-chip"><span>Help: ${escapeHtml(h)}</span><span class="remove-filter" data-remove-type="help" data-remove-value="${encodeAttr(h)}">√ó</span></div>`;
      });
      selectedDisruptions.forEach(d => {
        filtersHTML += `<div class="active-filter-chip"><span>Disruption: ${escapeHtml(d)}</span><span class="remove-filter" data-remove-type="disruption" data-remove-value="${encodeAttr(d)}">√ó</span></div>`;
      });
      selectedBreakdowns.forEach(b => {
        filtersHTML += `<div class="active-filter-chip"><span>Breakdown: ${escapeHtml(b)}</span><span class="remove-filter" data-remove-type="breakdown" data-remove-value="${encodeAttr(b)}">√ó</span></div>`;
      });
      selectedShooters.forEach(sh => {
        const icon = sh === 'Blue' ? 'üîµ' : sh === 'Green' ? 'üü¢' : '‚ö´';
        filtersHTML += `<div class="active-filter-chip"><span>${icon} ${escapeHtml(sh)} Shooter</span><span class="remove-filter" data-remove-type="shooter" data-remove-value="${encodeAttr(sh)}">√ó</span></div>`;
      });
      selectedResults.forEach(r => {
        filtersHTML += `<div class="active-filter-chip"><span>${escapeHtml(r)}</span><span class="remove-filter" data-remove-type="result" data-remove-value="${encodeAttr(r)}">√ó</span></div>`;
      });
      selectedPaintTouches.forEach(pt => {
        filtersHTML += `<div class="active-filter-chip"><span>Paint: ${escapeHtml(pt)}</span><span class="remove-filter" data-remove-type="paintTouches" data-remove-value="${encodeAttr(pt)}">√ó</span></div>`;
      });
      selectedShotLocations.forEach(sl => {
        filtersHTML += `<div class="active-filter-chip"><span>Location: ${escapeHtml(sl)}</span><span class="remove-filter" data-remove-type="shotLocation" data-remove-value="${encodeAttr(sl)}">√ó</span></div>`;
      });
      selectedShotContests.forEach(sc => {
        filtersHTML += `<div class="active-filter-chip"><span>Contest: ${escapeHtml(sc)}</span><span class="remove-filter" data-remove-type="shotContest" data-remove-value="${encodeAttr(sc)}">√ó</span></div>`;
      });
      selectedRebounds.forEach(r => {
        filtersHTML += `<div class="active-filter-chip"><span>Rebound: ${escapeHtml(r)}</span><span class="remove-filter" data-remove-type="rebound" data-remove-value="${encodeAttr(r)}">√ó</span></div>`;
      });

      Object.entries(searchQueries).forEach(([key, value]) => {
        const field = TEXT_SEARCH_FIELDS.find(f => f.key === key);
        const label = field ? field.label : key;
        const escapedVal = escapeHtml(value);
        filtersHTML += `<div class="active-filter-chip"><span>${label}: &quot;${escapedVal}&quot;</span><span class="remove-filter" data-remove-type="search" data-remove-value="${encodeAttr(key)}">√ó</span></div>`;
      });

      if (filtersHTML) {
        filtersHTML += `<button class="btn btn-clear active-filters-clear" type="button" style="margin-left: 0.5rem; padding: 0.5rem 1rem;">Clear All</button>`;
      }

      activeFiltersDiv.innerHTML = filtersHTML;
      const clearAllBtn = activeFiltersDiv.querySelector('.active-filters-clear');
      if (clearAllBtn) {
        clearAllBtn.addEventListener('click', clearAllFilters);
      }
      updateFilterCount();
    });

    // Clear filters
    function clearAllFilters() {
      document.querySelectorAll('.filter-panel input[type="checkbox"]').forEach(cb => cb.checked = false);
      TEXT_SEARCH_FIELDS.forEach(field => {
        const input = document.querySelector(`[data-filter-search="${field.key}"]`);
        if (input) input.value = '';
      });
      document.getElementById('gamesGrid').style.display = 'grid';
      document.getElementById('clipsSection').classList.add('hidden');
      document.getElementById('activeFilters').innerHTML = '';
      document.getElementById('filterPanel').classList.remove('open');
      document.getElementById('overlay').classList.remove('active');

      // Hide shot chart
      const shotChartPanel = document.getElementById('shotChartPanel');
      if (shotChartPanel) shotChartPanel.classList.add('hidden');

      currentViewClips = clips.slice();
      renderGames(getGamesForActiveView());
      updateStatsBar(clips);
      updateFilterCount();
    }

    document.getElementById('clearFilters').addEventListener('click', clearAllFilters);
    
    // Go back to games
    function goBackToGames() {
      document.getElementById('gamesGrid').style.display = 'grid';
      document.getElementById('clipsSection').classList.add('hidden');
      document.getElementById('activeFilters').innerHTML = '';

      // Hide shot chart
      const shotChartPanel = document.getElementById('shotChartPanel');
      if (shotChartPanel) shotChartPanel.classList.add('hidden');

      currentViewClips = clips.slice();
      renderGames(getGamesForActiveView());
      updateStatsBar(clips);
      const clipsGrid = document.getElementById('clipsGrid');
      if (clipsGrid) clipsGrid.style.display = 'grid';
      const spreadsheetView = document.getElementById('spreadsheetView');
      if (spreadsheetView) spreadsheetView.classList.remove('active');
      document.querySelectorAll('.view-btn').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.trim() === 'Grid');
      });
    }
    
    // Remove individual filter
    function removeFilter(type, value) {
      // Uncheck the corresponding checkbox
      if (type === 'game') {
        const checkbox = document.getElementById(`game-${value}`);
        if (checkbox) checkbox.checked = false;
      } else if (type === 'search') {
        const input = document.querySelector(`[data-filter-search="${value}"]`);
        if (input) input.value = '';
      } else {
        document.querySelectorAll(`[data-filter="${type}"]`).forEach(cb => {
          if (cb.value === value) cb.checked = false;
        });
      }
      
      // Re-apply filters
      document.getElementById('applyFilters').click();
    }

    // View toggle buttons
    document.querySelectorAll('.view-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const clipsGrid = document.getElementById('clipsGrid');
        const spreadsheetView = document.getElementById('spreadsheetView');
        document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        
        if (e.target.textContent === 'List') {
          clipsGrid.style.display = 'none';
          spreadsheetView.classList.add('active');
          // Populate spreadsheet if needed
          populateSpreadsheet();
        } else {
          clipsGrid.style.display = 'grid';
          spreadsheetView.classList.remove('active');
        }
      });
    });

    // Populate spreadsheet with current clips
    function populateSpreadsheet() {
      const spreadsheetBody = document.getElementById('spreadsheetBody');
      if (!spreadsheetBody) return;
      const dataset = currentViewClips.length ? currentViewClips : clips;
      const formatCell = (value) => {
        const text = cleanString(value || '', '');
        return text ? escapeHtml(text) : '<span class="empty-cell">‚Äî</span>';
      };
      
      spreadsheetBody.innerHTML = dataset.map((clip, index) => `
        <tr data-clip-id="${clip.id}">
          <td>${index + 1}</td>
          <td>${clip.gameId}</td>
          <td>${formatCell(getOpponentForClip(clip))}</td>
          <td>Q${clip.quarter}</td>
          <td>${clip.possession}</td>
          <td>${formatCell(clip.situation)}</td>
          <td>${formatCell(clip.formation)}</td>
          <td>${formatCell(clip.playName)}</td>
          <td>${formatCell(clip.scoutCoverage)}</td>
          <td>${formatCell(clip.actionTrigger)}</td>
          <td>${formatCell(clip.actionTypes)}</td>
          <td>${formatCell(clip.actionSequence)}</td>
          <td>${formatCell(clip.coverage)}</td>
          <td>${formatCell(clip.ballScreen)}</td>
          <td>${formatCell(clip.offBallScreen)}</td>
          <td>${formatCell(clip.helpRotation)}</td>
          <td>${formatCell(clip.disruption)}</td>
          <td>${formatCell(clip.breakdown)}</td>
          <td>${formatCell(clip.result)}</td>
          <td>${formatCell(clip.paintTouch)}</td>
          <td>${formatCell(clip.shooter)}</td>
          <td>${formatCell(clip.shotLocation)}</td>
          <td>${formatCell(clip.contest)}</td>
          <td>${formatCell(clip.rebound)}</td>
          <td>${clip.points}</td>
          <td style="max-width: 250px;">${formatCell(clip.notes)}</td>
        </tr>
      `).join('');
    }

    function bindFilterCheckboxListeners() {
      document.querySelectorAll('.filter-panel input[type="checkbox"]').forEach(cb => {
        if (cb.dataset.listenerBound === '1') return;
        cb.addEventListener('change', () => {
          updateFilterCount();
        });
        cb.dataset.listenerBound = '1';
      });
      TEXT_SEARCH_FIELDS.forEach(field => {
        const input = document.querySelector(`[data-filter-search="${field.key}"]`);
        if (input && input.dataset.listenerBound !== '1') {
          input.addEventListener('input', () => {
            updateFilterCount();
          });
          input.addEventListener('keydown', e => {
            if (e.key === 'Enter') {
              e.preventDefault();
              document.getElementById('applyFilters').click();
            }
          });
          input.dataset.listenerBound = '1';
        }
      });
    }

    function updateFilterCount() {
      const checkedCount = document.querySelectorAll('.filter-panel input[type="checkbox"]:checked').length;
      const searchCount = TEXT_SEARCH_FIELDS.reduce((sum, field) => {
        const input = document.querySelector(`[data-filter-search="${field.key}"]`);
        return sum + (cleanString(input?.value || '') ? 1 : 0);
      }, 0);
      const countEl = document.getElementById('filterCount');
      if (countEl) countEl.textContent = checkedCount + searchCount;
    }

    bindFilterCheckboxListeners();
    updateFilterCount();

    // Toggle shot chart accordion
    function toggleShotChart() {
      const panel = document.getElementById('shotChartPanel');
      if (panel) {
        panel.classList.toggle('collapsed');
      }
    }

    // Shot Chart Rendering (SVG-based, matches tagger coordinate system)
    function renderShotChart(clipsToShow, gameName) {

      const shotChartPanel = document.getElementById('shotChartPanel');
      const shotChartContainer = document.getElementById('shotChartContainer');
      const shotChartTitle = document.getElementById('shotChartTitle');
      const shotChartMeta = document.getElementById('shotChartMeta');
      const shotTooltip = document.getElementById('shotTooltip');

      if (!shotChartPanel || !shotChartContainer) return;

      // Store clips and gameId for editing
      currentGameClips = clipsToShow;
      currentGameId = clipsToShow.length > 0 ? clipsToShow[0].gameId : null;

      // Filter clips that have shot data
      const clipsWithShots = clipsToShow.filter(clip => {
        const hasValidShot = clip.has_shot === 'Yes' &&
                            clip.shot_x !== '' && clip.shot_x != null &&
                            clip.shot_y !== '' && clip.shot_y != null;
        return hasValidShot;
      });


      // If no shots, hide the panel
      if (clipsWithShots.length === 0) {
        shotChartPanel.classList.add('hidden');
        return;
      }

      // Show the panel
      shotChartPanel.classList.remove('hidden');

      // Update title and meta
      shotChartTitle.textContent = gameName ? `Shot Chart ‚Äî ${gameName}` : 'Shot Chart';
      shotChartMeta.textContent = `${clipsWithShots.length} shot${clipsWithShots.length > 1 ? 's' : ''}`;

      // Create court container with SVG overlay
      shotChartContainer.innerHTML = `
        <div class="shot-court-container">
          <div class="shot-court-bg"></div>
          <svg class="shot-overlay-svg" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet" id="shotOverlaySvg"></svg>
        </div>
      `;

      const svg = document.getElementById('shotOverlaySvg');
      const NS = 'http://www.w3.org/2000/svg';

      // Color mapping (hardcoded to match CSS variables)
      const COLORS = {
        designation: {
          Blue: '#3b82f6',
          Green: '#22c55e',
          Black: '#6b7280'
        },
        result: {
          Made: '#22c55e',
          Missed: '#ef4444'
        }
      };


      // Helper function to create half-circle path
      function halfPath(cx, cy, r, side) {
        if (side === 'left') {
          // Left half: from top, arc to bottom, close to center
          const x1 = cx - r;  // leftmost point
          const y1 = cy;      // middle height
          return `M ${cx} ${cy} L ${cx} ${cy - r} A ${r} ${r} 0 0 0 ${cx} ${cy + r} Z`;
        } else {
          // Right half: from top, arc to bottom, close to center
          const x1 = cx + r;  // rightmost point
          const y1 = cy;      // middle height
          return `M ${cx} ${cy} L ${cx} ${cy - r} A ${r} ${r} 0 0 1 ${cx} ${cy + r} Z`;
        }
      }

      // Render each shot
      clipsWithShots.forEach(clip => {
        const x = parseFloat(clip.shot_x);
        const y = parseFloat(clip.shot_y);

        if (isNaN(x) || isNaN(y)) return;

        // Apply same coordinate transform as tagger: invert Y
        const cx = Math.max(0, Math.min(100, x));
        const cy = Math.max(0, Math.min(100, 100 - y));
        const r = 2.2;

        // Determine designation - check both possible field names
        const designationRaw = clip.shooterDesignation || clip.shooter_designation || clip.shooter || 'Blue';
        const desigKey = /blue/i.test(designationRaw) ? 'Blue' : /green/i.test(designationRaw) ? 'Green' : 'Black';

        let resultRaw = clip.shot_result || '';
        // If no shot result, infer from play result
        if (!resultRaw) {
          resultRaw = clip.result || clip.play_result || '';
        }
        const resKey = /made/i.test(resultRaw) ? 'Made' : 'Missed';


        // Get colors
        const desigColor = COLORS.designation[desigKey];
        const resColor = COLORS.result[resKey];

        // Create marker group
        const markerGroup = document.createElementNS(NS, 'g');
        markerGroup.setAttribute('class', 'shot-marker');
        markerGroup.setAttribute('data-clip-id', clip.id);

        // Left half (designation)
        const leftHalf = document.createElementNS(NS, 'path');
        const leftPath = halfPath(cx, cy, r, 'left');
        leftHalf.setAttribute('d', leftPath);
        leftHalf.style.fill = desigColor;
        leftHalf.setAttribute('stroke', 'none');

        // Right half (result)
        const rightHalf = document.createElementNS(NS, 'path');
        const rightPath = halfPath(cx, cy, r, 'right');
        rightHalf.setAttribute('d', rightPath);
        rightHalf.style.fill = resColor;
        rightHalf.setAttribute('stroke', 'none');

        // Ring outline
        const ring = document.createElementNS(NS, 'circle');
        ring.setAttribute('cx', cx);
        ring.setAttribute('cy', cy);
        ring.setAttribute('r', r);
        ring.setAttribute('fill', 'none');
        ring.setAttribute('stroke', 'rgba(255, 255, 255, 0.5)');
        ring.setAttribute('stroke-width', '0.5');

        markerGroup.appendChild(leftHalf);
        markerGroup.appendChild(rightHalf);
        markerGroup.appendChild(ring);

        // Tooltip on hover
        markerGroup.addEventListener('mouseenter', (e) => {
          shotTooltip.innerHTML = `
            <div class="shot-tooltip-line"><strong>${clip.game}</strong> ‚Ä¢ Q${clip.quarter} P${clip.possession}</div>
            <div class="shot-tooltip-line">${clip.playName || 'Defensive Possession'}</div>
            <div class="shot-tooltip-line">${designationRaw} Shooter ‚Ä¢ ${resKey}</div>
            <div class="shot-tooltip-line">Contest: ${clip.shotContest || '‚Äî'}</div>
          `;
          shotTooltip.style.display = 'block';

          // Position tooltip below the marker
          const rect = markerGroup.getBoundingClientRect();
          shotTooltip.style.left = `${rect.left + rect.width / 2 - shotTooltip.offsetWidth / 2}px`;
          shotTooltip.style.top = `${rect.bottom + 8}px`;
        });

        markerGroup.addEventListener('mouseleave', () => {
          shotTooltip.style.display = 'none';
        });

        markerGroup.addEventListener('mousemove', (e) => {
          // Update tooltip position as mouse moves
          const rect = markerGroup.getBoundingClientRect();
          shotTooltip.style.left = `${rect.left + rect.width / 2 - shotTooltip.offsetWidth / 2}px`;
          shotTooltip.style.top = `${rect.bottom + 8}px`;
        });

        // Click to navigate to clip detail or edit shot
        markerGroup.addEventListener('click', (e) => {
          if (shotEditMode) {
            e.stopPropagation();
            openShotEditor(clip);
          } else {
            openClipDetail(clip.id);
          }
        });

        svg.appendChild(markerGroup);
      });
    }

    // Shot Chart Editor
    let shotEditMode = false;
    let currentGameClips = [];
    let currentGameId = null;
    let editingClipId = null;

    document.getElementById('editShotChartBtn').addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent collapsing the panel
      shotEditMode = !shotEditMode;
      const btn = e.target;
      btn.textContent = shotEditMode ? 'Done' : 'Edit';
      btn.style.background = shotEditMode ? 'var(--ou-crimson)' : '';

      // Re-render to enable/disable edit mode using the stored clips
      const gameName = document.getElementById('shotChartTitle').textContent.replace('Shot Chart ‚Äî ', '');
      renderShotChart(currentGameClips, gameName);
    });

    function openShotEditor(clip) {
      editingClipId = clip.id;

      // Populate clip dropdown with all clips from current game
      const select = document.getElementById('shotEditClip');
      select.innerHTML = currentGameClips.map(c =>
        `<option value="${c.id}" ${c.id === clip.id ? 'selected' : ''}>
          Q${c.quarter} P${c.possession} - ${c.playName || 'Defensive Possession'} (${c.id})
        </option>`
      ).join('');

      // Populate fields
      document.getElementById('shotEditX').value = clip.shot_x || '';
      document.getElementById('shotEditY').value = clip.shot_y || '';
      document.getElementById('shotEditDesignation').value = clip.shooterDesignation || 'Blue';

      let result = clip.shot_result || '';
      if (!result) {
        result = /made/i.test(clip.result || '') ? 'Made' : 'Missed';
      }
      document.getElementById('shotEditResult').value = result;


      // Show modal
      document.getElementById('shotEditorModal').style.display = 'flex';
    }

    function closeShotEditor() {
      document.getElementById('shotEditorModal').style.display = 'none';
      editingClipId = null;
    }

    document.getElementById('shotEditCancel').addEventListener('click', closeShotEditor);

    document.getElementById('shotEditSave').addEventListener('click', async () => {
      const clipId = document.getElementById('shotEditClip').value;
      const shotX = document.getElementById('shotEditX').value;
      const shotY = document.getElementById('shotEditY').value;
      const designation = document.getElementById('shotEditDesignation').value;
      const result = document.getElementById('shotEditResult').value;

      if (!shotX || !shotY) {
        alert('Shot X and Y coordinates are required');
        return;
      }

      try {

        const response = await fetch(`${API_URL}/api/clip/${clipId}/shot`, {
          method: 'PUT',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            has_shot: 'Yes',
            shot_x: shotX,
            shot_y: shotY,
            shot_result: result,
            shooter_designation: designation
          })
        });

        const responseData = await response.json();

        if (!response.ok) {
          throw new Error(responseData.error || 'Failed to update shot');
        }

        closeShotEditor();

        // Reload clips and refresh shot chart
        await reloadClipsData();
        const filtered = clips.filter(c => c.gameId === currentGameId);
        const gameName = filtered.length > 0 ? filtered[0].game : 'Unknown';
        renderClips(filtered);
        renderShotChart(filtered, gameName);
        currentViewClips = filtered.slice();
        const spreadsheetView = document.getElementById('spreadsheetView');
        const clipsGrid = document.getElementById('clipsGrid');
        if (spreadsheetView && clipsGrid) {
          if (spreadsheetView.classList.contains('active')) {
            clipsGrid.style.display = 'none';
            populateSpreadsheet();
          } else {
            clipsGrid.style.display = 'grid';
          }
        }

        alert('Shot updated successfully!');
      } catch (err) {
        console.error('Error updating shot:', err);
        alert('Failed to update shot: ' + err.message + '. Check console for details.');
      }
    });

    document.getElementById('shotEditDelete').addEventListener('click', async () => {
      if (!confirm('Delete this shot? This cannot be undone.')) return;

      const clipId = document.getElementById('shotEditClip').value;

      try {
        const response = await fetch(`${API_URL}/api/clip/${clipId}/shot`, {
          method: 'DELETE'
        });

        if (!response.ok) throw new Error('Failed to delete shot');

        closeShotEditor();

        // Reload clips and refresh shot chart
        await reloadClipsData();
        const filtered = clips.filter(c => c.gameId === currentGameId);
        const gameName = filtered.length > 0 ? filtered[0].game : 'Unknown';
        renderClips(filtered);
        renderShotChart(filtered, gameName);
        currentViewClips = filtered.slice();
        const spreadsheetView = document.getElementById('spreadsheetView');
        const clipsGrid = document.getElementById('clipsGrid');
        if (spreadsheetView && clipsGrid) {
          if (spreadsheetView.classList.contains('active')) {
            clipsGrid.style.display = 'none';
            populateSpreadsheet();
          } else {
            clipsGrid.style.display = 'grid';
          }
        }

        alert('Shot deleted successfully!');
      } catch (err) {
        console.error('Error deleting shot:', err);
        alert('Failed to delete shot. See console for details.');
      }
    });
  </script>
</body>
</html>
