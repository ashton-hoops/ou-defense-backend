<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>OU WBB DEFENSIVE CLIP TAGGER </title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
:root { --side-w: 360px; --accent:#fff; --tools-card-height: clamp(300px, calc(100vh - 240px), 680px); }
html,body{max-width:100%; overflow-x:hidden;}
body { background:#000; color:#fff; font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Inter,Arial,sans-serif; }

/* remove macOS blue focus ring */
input:focus,
textarea:focus,
select:focus,
button:focus {
  outline: none !important;
  box-shadow: none !important;
  border-color: var(--ou-crimson, #841617) !important; /* or any color you prefer */
}


.app-header { background:#000; border-bottom:1px solid #fff; }
.app-header .accent { height:3px; background:#fff; }

.panel  { background:##1C1C1C; border-radius:12px; border:1px solid #841617; box-shadow: 0 4px 10px rgba(0,0,0,.35); }

.grid-main{
  display:grid;
  grid-template-areas: 
    "video pbp"
    "controls pbp"
    "tags tags";
  grid-template-columns: 1fr var(--side-w);
  grid-template-rows: auto minmax(36px,auto) auto;
  gap:16px;
  min-height: calc(100vh - 64px);
  padding-bottom: 32px;
}
/* === Controls Row Layout === */
#controlsPane.panel.controls {
  display: flex;
  align-items: center;
  justify-content: center;  /* or space-between if you want it stretched */
  gap: 8px;                 /* consistent spacing between items */
  flex-wrap: nowrap;        /* keep everything on one line */
  flex-shrink: 0;
}
/* Make Excel Row input match IN/OUT */
#inTime, #outTime, #rowInline {
  background:#161616 !important;
  border-color:#2a2a2a !important;
  color:#f0f0ec !important;
}

/* (optional) keep sizing consistent with the controls row */
#rowInline {
  height:26px;
  font-size:.78rem;
  text-align:center;
}

#controlsPane .inline-group {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  white-space: nowrap;      /* keeps Excel Row + input on same line */
}

/* Move Export CSV next to Close button */
.drawer-head {
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.drawer-head > #exportCsv {
  order: 2;              /* moves button to the right side */
  margin-left: auto;     /* pushes it next to Close */
  margin-right: .5rem;   /* add small gap before Close */
}

.drawer-head > #toggleDrawer {
  order: 3;              /* keep Close as last */
}


#videoPane{
  grid-area: video;
  position:relative;
  display:flex;
  flex-direction:column;
  min-height:0;
  align-self:stretch;
  height:calc(var(--tools-card-height) + 10px);
  max-height:calc(var(--tools-card-height) + 10px);
}
#controlsPane{ grid-area: controls; }
#pbpPane{ grid-area: pbp; position:relative; }
#tagsPane{ grid-area: tags; }

#videoInput{ display:none; }
.video-wrap{
  position:relative;
  width:100%;
  flex:1 1 auto;
  min-height:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:#000;
  border-radius:10px;
  overflow:hidden;
}
video{
  width:100%;
  height:100%;
  object-fit:contain;
  background:#000;
  display:block;
}
.overlay{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; }
.overlay button{ pointer-events:auto; width:72px; height:72px; border-radius:999px; border:1px solid #841617; background:rgba(17,21,25,.88); display:flex; align-items:center; justify-content:center; }
.tri{ width:0; height:0; border-left:18px solid #e5e7eb; border-top:12px solid transparent; border-bottom:12px solid transparent; margin-left:4px; }
.overlay.hidden{ opacity:0; visibility:hidden; }

.pbp-header{ position:sticky; top:0; z-index:2; display:flex; align-items:center; justify-content:space-between; padding:.5rem .7rem; border-bottom:1px solid #1f2730; background:#841617; border-radius:8px; }
textarea.pbp{
  width:100%;
  flex:1 1 auto;
  min-height:0;
  resize:none;
  background:#000;
  border:1px solid #841617;
  border-radius:10px;
  color:#fff;
  padding:.75rem;
  font:11px/1.35 ui-monospace, Menlo, Consolas, monospace;
}

/* --- PBP panel becomes a scrollable column card --- */
#pbpPane.panel{
  display:flex;
  flex-direction:column;
  overflow:hidden;                        /* the card itself */
  height:calc(var(--tools-card-height) + 56px);
  max-height:calc(var(--tools-card-height) + 56px);
}
.pbp-body{ 
  flex:1 1 auto;
  padding-bottom:0;
  display:flex;
  flex-direction:column;
  min-height:0;
  overflow:hidden;
}

/* --- Shot Picker Toolbar --- */
.shot-toolbar{
  background:#141414;
  border:1px dashed #2b2b2b;
  border-radius:10px;
  padding:12px;
  display:flex;
  flex-direction:column;
  gap:12px;
  flex:1 1 auto;
  min-height:0;
  box-sizing:border-box;
  overflow-y:auto;
}
.shot-toolbar .shot-top{
  flex:1;
  min-height:0;
  display:flex;
  flex-direction:column;
  gap:12px;
}
.shot-toolbar .row{ display:flex; gap:12px; align-items:flex-start; flex-wrap:wrap; width:100%; min-width:0; flex:1 1 auto; }
.shot-toolbar .field{ min-width:140px; }
.shot-toolbar label{ display:block; font-size:12px; color:#c9c6c0; margin-bottom:4px; }
.shot-toolbar input, .shot-toolbar select{
  background:#1c1c1c; border:1px solid #2a2a2a; color:#f5f5f2; border-radius:8px; padding:6px 8px; width:160px;
}
.shot-toolbar input[type="checkbox"]{
  width:auto;
  min-width:0;
  height:auto;
  padding:0;
  background:none;
  border:none;
}
.shot-toggle{
  display:inline-flex !important;
  align-items:center;
  gap:0 !important;
  margin:0 !important;
  padding:0 !important;
  white-space:nowrap;
}
.shot-toggle input{
  margin:0 !important;
  margin-right:2px !important;
}

/* court canvas */
.court-wrap{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; justify-content:center; }
.court-wrap > div:last-child{ flex:1 1 160px; min-width:160px; }

/* marker ring and halves */
.mrk-ring{ stroke:#000; stroke-width:.25; opacity:.45; fill:none; }
.mrk-half-left{ }
.mrk-half-right{ }

/* tiny legend */
.shot-legend{ display:flex; gap:10px; flex-wrap:wrap; font-size:11px; color:#c9c6c0; margin-top:6px;}
.shot-legend .sw{ width:10px; height:10px; border-radius:2px; display:inline-block; margin-right:6px; }

/* colors (consistent with your project) */
:root{
  --col-blue:#3aa3ff;   /* Primary */
  --col-green:#30d158;  /* Shooter */
  --col-black:#111111;  /* Role */
  --col-made:#24c94a;   /* result */
  --col-miss:#e34a4a;
}

.controls{ display:flex; align-items:center; justify-content:center; gap:.35rem; padding:.22rem .4rem; background:#000; border:1px solid #1c242d; border-radius:10px; }
.controls .ctl{ background:#841617; border:1px solid #26303a; padding:.28rem .48rem; border-radius:7px; font-size:.68rem; line-height:1; min-width:58px; }
.controls input{ height:26px; font-size:.8rem;  width:75px;  }
.sep{ color:#fff; font-size:12px; margin:0 .35rem; }
.controls {
  flex: 0 0 auto;
}
.controls .ctl {
  padding:.28rem .38rem;
  min-width:45px;
}

/* Tags row */
#tagsPane{ overflow-x:auto; }
.tag-row{
  width:max-content; display:flex; flex-wrap:nowrap; align-items:flex-start;
  gap:10px; padding:8px 10px; background:#000; border:1px solid #1b2229; border-radius:12px;
}
.tag-field{ flex:0 0 auto; min-width:190px; width:max-content; display:flex; flex-direction:column; gap:4px; }
.tag-field.narrow{ min-width:140px; }
.tag-input{ width:fit-content; min-width:190px; max-width:560px; background:#841617; border:1px solid #fff; color:#fff; border-radius:8px; padding:6px 8px; }
.tag-label{ font-size:12px; color:#fff; }

/* Drawer */
.drawer-tab{
  position:fixed; bottom:0; left:50%; transform:translateX(-50%);
  background:var(--panel);                     /* match cards */
  border:1px solid var(--panel-b);             /* match cards */
  border-bottom:none;
  border-top-left-radius:10px; border-top-right-radius:10px;
  padding:.35rem .8rem; font-size:.8rem; color:var(--ink); /* match text tone */
  cursor:pointer; z-index:40;
  box-shadow:0 -2px 10px rgba(0,0,0,.35);
}

/* keep these OUTSIDE any other block */
.drawer.hidden { display:none; }
.drawer.open   { display:block; transform:translateY(0%); }

.drawer{
  position:fixed; left:0; right:0; bottom:0; z-index:45;
  background:var(--panel);                      /* match cards */
  border-top:1px solid var(--panel-b);         /* match cards */
  transform:translateY(calc(100% - 36px));
  transition:transform .22s ease;
  box-shadow:0 -8px 24px rgba(0,0,0,.45);
}
.drawer-head{
  display:flex; align-items:center; justify-content:space-between;
  padding:.5rem .9rem;
  background:var(--panel);                      /* match cards */
  border-bottom:1px solid var(--line);          /* match cards */

}
/* optional fine-tune for alignment */
.drawer-head button {
  margin-right: 12px;
  transform: translateY(1px);  /* nudge down 1px for perfect visual line-up */
}
.drawer-body{ max-height:40vh; overflow:auto; padding:0; }

.queue-table{ width:100%; border-collapse:collapse; table-layout:fixed; font-size:.84rem; }
.queue-table thead{ position:sticky; top:0; background:var(--panel); } /* match */
.queue-table th, .queue-table td{
  padding:.5rem .6rem; white-space:nowrap; border-bottom:1px solid var(--panel-b);
}
.queue-table th, .queue-table td {
  vertical-align: middle;
  text-align: center;       /* keeps columns like Q / Poss centered */
}
.queue-table th:first-child,
.queue-table td:first-child {
  text-align: center;       /* ensures # column stays centered */
}
.queue-table td {
  padding-top: .45rem;
  padding-bottom: .45rem;   /* equal top/bottom so text aligns perfectly */
}

/* keep your hover/delete styles if you like the red accent */
.queue-row{ cursor:pointer; }
.queue-row:hover{ background:#17212b; }
.queue-row.unselected{ opacity:.55; }
.queue-row.unselected:hover{ background:#1b2732; opacity:.7; }
.del-btn{ background:#772b2b; border:1px solid #8a3a3a; color:#fff; border-radius:8px; padding:.25rem .5rem; font-size:.75rem; }
.del-btn:hover{ background:#963a3a; }
.muted{ color:var(--ink); font-size:.85rem; }

/* Excel status */
.excel-btn{ cursor:pointer; padding:4px 12px; border-radius:6px; font-size:12px; transition:all .2s; }
.excel-btn.inactive{ background:#841617; color:#fff; }
.excel-btn.active{ background:#166534; color:#bbf7d0; }
.excel-btn:hover{ opacity:.99; }

/* Modal */
.modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,.7); z-index:50; display:none; align-items:center; justify-content:center; }
.modal-overlay.show{ display:flex; }
.modal-box{ background:#1a1f26; border:1px solid #2a2f35; border-radius:12px; padding:1.5rem; max-width:400px; width:90%; }
.modal-title{ font-size:1.1rem; font-weight:600; margin-bottom:1rem; }
.modal-input{ width:100%; background:#2b323a; border:1px solid #3a4149; color:#fff; border-radius:8px; padding:8px 12px; margin:8px 0; }
.modal-btns{ display:flex; gap:8px; margin-top:1rem; }
.modal-btn{ flex:1; padding:8px 16px; border-radius:8px; font-size:14px; cursor:pointer; transition:.2s; }
.modal-btn.primary{ background:#841617; color:#fff; }
.modal-btn.primary:hover{ background:#9a1a1b; }
.modal-btn.secondary{ background:#2a2f35; color:#e5e7eb; }
.modal-btn.secondary:hover{ background:#353b42; }

/* Ensure the video remains interactive (no pointer swallowing) */
#video, #video * { pointer-events: auto !important; }
.overlay { pointer-events: none !important; }
.overlay button { pointer-events: auto !important; }

/* Floating picker (overlay dropdown) */
#floatPicker {
  position: fixed;
  z-index: 9999;
  background:#000;
  border:1px solid #24303b;
  border-radius:8px;
  box-shadow:0 8px 18px rgba(0,0,0,.35);
  max-height:260px;
  overflow:auto;
  display:none;
  min-width:220px;
}
.fp-item{ padding:8px 10px; cursor:pointer; font-size:13px; white-space:nowrap; }
.fp-item:hover{ background:#18222c; }
.fp-empty{ padding:8px 10px; color:#94a3b8; font-size:12px; }
</style>
<!-- === TOOLS LAYOUT FIX (NO SIDE SCROLL) === -->
<style>
/* Treat the right-hand card as the "Tools" pane (your existing id is pbpPane) */
#pbpPane {
  overflow-x: hidden !important;
  display:flex;
  flex-direction:column;
  height:calc(var(--tools-card-height) + 56px);
  max-height:calc(var(--tools-card-height) + 56px);
}
#pbpPane .pbp-body {
  overflow-x: hidden !important;
  display:flex;
  flex-direction:column;
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}

#shotToolbar {
  width: 100%;
  max-width: 100%;
  box-sizing: border-box;
  flex:1;
  min-height:0;
}

/* Flex children must be allowed to shrink to avoid overflow */
.court-wrap {
  display: flex;
  gap: 12px;
  align-items: flex-start;
  flex-wrap: wrap;
  width: 100%;
  min-width: 0;
}
.court-wrap > * { min-width: 0; }

/* Court sizing — match container width; keep aspect ratio; never exceed card */
.court{
  width: min(320px, 100%) !important;
  max-width: 100%;
  aspect-ratio: 500 / 472;
  position: relative;
  border: 1px solid #3b3b3b;
  border-radius: 12px;
  overflow: hidden;
  background-color: #f6efe0;
  background-image: url('assets/shot_court.webp');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  box-sizing: border-box;
  margin: 0 auto;
}

/* If a <picture>/<img> fallback exists, force it to fit container without overflow */
.court picture,
.court img {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: contain;
  user-select: none;
  pointer-events: none;
}

/* Overlay must never exceed the court box */
.court-ov{
  position:absolute;
  inset:0;
  display:block;
  width:100%;
  height:100%;
}

/* Inputs area wraps within the same width, no overflow */
.shot-toolbar .fields,
.shot-toolbar .row {
  display:flex;
  gap:12px;
  flex-wrap:wrap;
  width:100%;
  min-width:0;
}
.shot-toolbar .fields{
  margin-top:auto;
  padding-top:8px;
  border-top:1px dashed rgba(255,255,255,.08);
  flex:0 0 auto;
}
.shot-toolbar .fields .field{ flex:1 1 140px; min-width:140px; }
.shot-toolbar input,
.shot-toolbar select{
  width:140px;
  max-width:100%;
}

#pbpTabs{
  display:flex;
  gap:6px;
  background:#161616;
  padding:3px;
  border-radius:8px;
  border:1px solid #2e2e2e;
}
.tab-btn{
  border:0;
  background:rgba(255,255,255,.06);
  color:#f3f4f6;
  font-size:11px;
  font-weight:600;
  letter-spacing:.04em;
  padding:6px 12px;
  border-radius:6px;
  cursor:pointer;
  transition:all .18s ease;
}
.tab-btn:hover{ background:rgba(255,255,255,.12); }
.tab-btn.active{
  background:#841617;
  color:#fff;
  box-shadow:0 0 0 1px rgba(255,255,255,.08);
}

.tool-pane{
  display:none;
  flex-direction:column;
  min-height:0;
  gap:12px;
  overflow:hidden;
}
.tool-pane.active{
  display:flex;
  flex:1 1 auto;
  overflow:hidden;
}

.filter-actions{
  display:flex;
  gap:12px;
  margin-bottom:12px;
}

#pbpPane .pbp-body{
  display:flex;
  flex-direction:column;
  flex:1 1 auto;
  min-height:0;
  overflow:hidden;
}

#pbpFilterPane textarea{
  flex:1;
  min-height:0;
  height:100%;
}
</style>
<style>
.mini-shot { width:56px; height:52px; display:inline-block; border:1px solid #333; border-radius:8px; background:#f6efe0; }
.mini-shot svg{ width:100%; height:100%; display:block; }
</style>
<!-- === END TOOLS LAYOUT FIX === -->
<script src="scripts/shared/location.js"></script>
</head>
<body>
<main class="p-4" style="padding-top:24px;">
  <div class="grid-main">

    <section id="videoPane" class="panel p-3">
      <input id="videoInput" type="file" accept="video/*"/>
      <div class="video-wrap">
        <video id="video" controls preload="metadata" playsinline>
          <source id="videoSrc" type="video/mp4">
        </video>
        <div id="overlay" class="overlay">
          <button id="playOverlay" aria-label="Play"><span class="tri"></span></button>
        </div>
      </div>
    </section>

<section id="controlsPane" class="panel controls">
  <button class="ctl load" id="loadBtn" type="button">Load Video</button>
  <button class="ctl" data-speed="0.5">0.5x</button>
  <button class="ctl" data-speed="1">1x</button>
  <button class="ctl" data-speed="2">2x</button>
  <span class="sep">|</span>
  <button class="ctl" data-skip="-10">-10s</button>
  <button class="ctl" id="ppBtn">▶/⏸</button>
  <button class="ctl" data-skip="10">+10s</button>
  <span class="sep">|</span>
  <input id="inTime" placeholder="IN"  class="bg-[#121820] border border-[#1e2730] rounded px-2 text-center w-24"/>
  <input id="outTime" placeholder="OUT" class="bg-[#121820] border border-[#1e2730] rounded px-2 text-center w-24"/>

  <button class="ctl" id="markIn">Mark IN</button>
  <button class="ctl ml-1" id="markOut">Mark OUT</button>

  <!-- Excel row label + input -->
  <div class="inline-group ml-3">
    <span class="text-xs text-slate-400 select-none">Excel Row</span>
    <input id="rowInline" type="number" min="2" value="2"
      class="bg-[#121820] border border-[#1e2730] rounded px-2 text-center w-20"
      title="Excel row to save into">
  </div>

  <!-- Save AFTER the Excel Row input -->
  <button class="ctl ml-2" id="save">Save</button>
</section>


    <aside id="pbpPane" class="panel p-3">
      <div class="pbp-header">
        <h2 class="font-semibold text-sm tracking-wide">Tagging Tools</h2>
        <div id="pbpTabs">
          <button class="tab-btn active" data-tab="filter">Play Filter</button>
          <button class="tab-btn" data-tab="shot">Shot Chart</button>
        </div>
      </div>
      <div class="pbp-body mt-2">
        <section id="pbpFilterPane" class="tool-pane active">
          <div class="filter-actions">
            <button id="filterPBP" class="bg-neutral-800 hover:bg-neutral-700 px-3 py-2 rounded text-xs">Filter OU Defense</button>
            <button id="clearPBP" class="bg-neutral-800 hover:bg-neutral-700 px-3 py-2 rounded text-xs">Clear</button>
          </div>
          <textarea id="pbpText" class="pbp" placeholder="Paste ESPN Play-by-Play here..."></textarea>
        </section>

        <!-- ===== Shot Picker Toolbar (as alternate tool pane) ===== -->
        <section id="shotPane" class="tool-pane">
          <div class="shot-toolbar" id="shotToolbar">
            <div class="shot-top">
              <div style="font-weight:600;">Shot Chart Picker</div>
              <div class="row">
                <!-- Court -->
                <div class="court-wrap">
                  <div id="shotCourt" class="court">
                    <picture>
                      <source srcset="assets/shot_court.webp" type="image/webp">
                      <img src="assets/shot_court.png" alt="Court" style="position:absolute;inset:0;width:100%;height:100%;object-fit:contain;user-select:none;pointer-events:none;">
                    </picture>
                    <svg id="shotOverlay" class="court-ov" viewBox="0 0 100 100"></svg>
                  </div>
                  <div>
                    <div class="shot-legend">
                      <span><span class="sw" style="background:var(--col-blue)"></span>Blue (Primary)</span>
                      <span><span class="sw" style="background:var(--col-green)"></span>Green (Shooter)</span>
                      <span><span class="sw" style="background:var(--col-black)"></span>Black (Role)</span>
                      <span><span class="sw" style="background:var(--col-made)"></span>Made</span>
                      <span><span class="sw" style="background:var(--col-miss)"></span>Missed</span>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <!-- Fields -->
            <div class="row fields">
              <div class="field">
                <label for="shotX">Shot X</label>
                <input id="shotX" placeholder="0–100">
              </div>
              <div class="field">
                <label for="shotY">Shot Y</label>
                <input id="shotY" placeholder="0–100">
              </div>
              <div class="field">
                <label for="shotResultPicker">Shot Result</label>
                <select id="shotResultPicker">
                  <option value="">(Use Play Result if blank)</option>
                  <option value="Made">Made</option>
                  <option value="Missed">Missed</option>
                </select>
              </div>
              <div class="field">
                <label for="shotDesigPicker">Designation</label>
                <select id="shotDesigPicker">
                  <option value="">(Use Shooter Designation if blank)</option>
                  <option>Blue</option>
                  <option>Green</option>
                  <option>Black</option>
                </select>
              </div>
              <div style="display:flex !important;align-items:center;font-size:12px;color:#c9c6c0;flex:1 1 100%;padding-top:8px;justify-content:flex-start;">
                <label class="shot-toggle" for="includeShot" style="cursor:pointer;">
                  <input id="includeShot" type="checkbox" />
                  <span style="line-height:1.2;">Include shot on save (optional)</span>
                </label>
              </div>
            </div>
          </div>
        </section>
      </div>
    </aside>

<style>
/* ===== THEME OVERRIDES: GRAPHITE–CREAM ===== */
:root{
  --ou:#841617; --ou-d:#6C1116; --cream:#FDF9E8;
  --page:#141414; --panel:#1a1a1a; --panel-b:#2a2a2a;
  --ink:#f5f5f2; --muted:#c9c6c0; --line:#333; 
}
body{ background:var(--page) !important; color:var(--ink) !important; }
.app-header{ background:#000 !important; border-bottom:1px solid #fff !important; }
.app-header .accent{ background:#fff !important; opacity:1 !important; }

.panel{ background:var(--panel) !important; border-color:var(--panel-b) !important; box-shadow:0 8px 24px rgba(0,0,0,.35) !important; }
.overlay button{ background:rgba(0,0,1) !important; border-color:#333 !important; }
.tri{ border-left-color:#2f2f2f !important; }

.pbp-header{ background:#1c1c1c !important; border-bottom:1px solid var(--line) !important; }
textarea.pbp{ background:#0c0c0c !important; border-color:#333 !important; color:#f0f0ec !important; }

.controls{ background:#191919 !important; border-color:#2a2a2a !important; }
.controls .ctl{ background:#202020 !important; border-color:#333 !important; color:#f2f2ef !important; font-size:.68rem !important; }
.controls .ctl:hover{ border-color:var(--ou) !important; box-shadow:0 0 0 2px rgba(132,22,23,.25) inset !important; }
.sep{ color:#7f7f7f !important; }
#inTime,#outTime{ background:#161616 !important; border-color:#2a2a2a !important; color:#f0f0ec !important; }

#tagsPane .tag-row{ background:#191919 !important; border-color:#2a2a2a !important; }
.tag-label{ color:#e8e2d6 !important; }
.tag-input{ background:#252525 !important; border-color:#363636 !important; color:#faf9f6 !important; }
.tag-input:focus{ border-color:var(--ou) !important; box-shadow:0 0 0 2px rgba(132,22,23,.24) !important; }

.drawer-tab{ background:#181818 !important; border-color:#2a2a2a !important; color:#f0eee8 !important; }
.drawer{ background:#121212 !important; border-top:1px solid #2a2a2a !important; }
.drawer-head{ background:#191919 !important; border-bottom:1px solid #333 !important; }
.queue-table thead{ background:#191919 !important; }
.queue-table th,.queue-table td{ border-bottom:1px solid #2a2a2a !important; color:#f0eee8 !important; }
.queue-row:hover{ background:#841617 !important; }

.del-btn{ background:#000 !important; border-color:#872021 !important; color:#fff !important; }
.del-btn:hover{ background:#2a2a2a !important; }

.excel-btn.inactive{ background:#2a2a2a !important; color:#841617 !important; }
.excel-btn.active{ background:#252525 !important; color:#faf9f6 !important; }

.modal-box{ background:#1c1c1c !important; border-color:#333 !important; }
.modal-input{ background:#252525 !important; border-color:#3a3a3a !important; color:#faf9f6 !important; }
.modal-btn.primary{ background:var(--ou) !important; }
.modal-btn.primary:hover{ background:var(--ou-d) !important; }

#floatPicker{ background:#161616 !important; border:1px solid #2f2f2f !important; }
.fp-item{ color:#f0eee8 !important; }
.fp-item:hover{ background:#841617 !important; }
.fp-empty{ color:#c9c6c0 !important; }

html, body {
  overflow-x: hidden !important;
}
#tagRow,
.tag-row {
  overflow-x: auto;
  scrollbar-width: thin;
  scrollbar-color: #3b3b3b #1a1a1a;  /* thumb / track */
}

#tagRow::-webkit-scrollbar,
.tag-row::-webkit-scrollbar {
  height: 6px;
}
#tagRow::-webkit-scrollbar-track,
.tag-row::-webkit-scrollbar-track {
  background: #1a1a1a;
  border-radius: 6px;
}
#tagRow::-webkit-scrollbar-thumb,
.tag-row::-webkit-scrollbar-thumb {
  background: #3b3b3b;
  border-radius: 6px;
}
#tagRow::-webkit-scrollbar-thumb:hover,
.tag-row::-webkit-scrollbar-thumb:hover {
  background: #4a4a4a;
}

</style>
<!-- JetBrains Mono global font override (ESPN / analytical style) -->
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">

<!-- Inter global font override -->
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<style>
*,
*::before,
*::after {
  font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif !important;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
body {
  font-weight: 400 !important;
  letter-spacing: 0.1px;
  line-height: 1.45;
}
h1, h2, h3, h4, h5, h6 {
  font-weight: 600 !important;
  letter-spacing: 0.25px;
}
button, input, select, textarea {
  font-family: inherit !important;
}
textarea.pbp, .mono, .timecode {
  font-family: 'JetBrains Mono', monospace !important;
  font-size: 0.8em;
}
</style>




    <!-- ======================= TAGS / CATEGORIES ======================= -->
    <section id="tagsPane" class="panel p-2">
      <div class="tag-row" id="tagRow">
        <div class="tag-field narrow">
          <span class="tag-label">Game #</span>
          <input class="tag-input" id="gameNum" type="number" min="1" value="1">
        </div>

        <div class="tag-field narrow">
          <span class="tag-label">Location</span>
          <input class="tag-input" id="gameLocation" list="locationOptions" placeholder="Home / Away / Neutral">
        </div>

        <div class="tag-field">
          <span class="tag-label">Opponent</span>
          <input class="tag-input" id="opponent">
        </div>

        <div class="tag-field narrow">
          <span class="tag-label">Quarter</span>
          <input class="tag-input" id="quarter" type="number" min="1" max="4" value="1">
        </div>

        <div class="tag-field narrow">
          <span class="tag-label">Possession #</span>
          <input class="tag-input" id="possession" type="number" min="1" value="1">
        </div>

        <div class="tag-field">
          <span class="tag-label">Situation</span>
          <input class="tag-input" id="situation" list="situationOptions" placeholder="Half Court / SLOB / Transition">
        </div>

        <div class="tag-field">
          <span class="tag-label">Offensive Formation</span>
          <input class="tag-input" id="offFormation" placeholder="Horns / 5-Out / 1-4 High">
        </div>

        <div class="tag-field">
          <span class="tag-label">Play Name</span>
          <input class="tag-input" id="playName" placeholder="Horns Flare">
        </div>

        <div class="tag-field narrow">
          <span class="tag-label">Covered in Scout?</span>
          <input class="tag-input" id="scoutTag" list="scoutOptions" placeholder="Yes – Practiced / Partial / No">
        </div>

        <div class="tag-field">
          <span class="tag-label">Action Trigger</span>
          <input class="tag-input" id="actionTrigger" placeholder="Entry to wing">
        </div>

        <div class="tag-field">
          <span class="tag-label">Action Type(s)</span>
          <input class="tag-input" id="actionTypes" placeholder="comma-separated">
        </div>

        <div class="tag-field">
          <span class="tag-label">Action Sequence</span>
          <input class="tag-input" id="actionSeq" placeholder="Horns → Stagger → DHO">
        </div>

        <div class="tag-field">
          <span class="tag-label">Defensive Coverage</span>
          <input class="tag-input" id="coverage" list="coverageOptions" placeholder="Man / 2-3 / 3-2 / 1-3-1 / 1-2-2 / Press">
        </div>

        <div class="tag-field">
          <span class="tag-label">Ball Screen Coverage</span>
          <input class="tag-input" id="ballScreenCov" list="ballScreenOptions" placeholder="*(Drop/Stuck/Late) if nec.">
        </div>

        <div class="tag-field">
          <span class="tag-label">Off-Ball Screen Coverage</span>
          <input class="tag-input" id="offBallScreenCov" list="offBallOptions" placeholder="*(Drop/Stuck/Late) if nec.">
        </div>

        <div class="tag-field">
          <span class="tag-label">Help/Rotation</span>
          <input class="tag-input" id="helpRotation" list="helpOptions" placeholder="Low-Man Help / X-Out Rotation">
        </div>

        <div class="tag-field">
          <span class="tag-label">Defensive Disruption</span>
          <input class="tag-input" id="defDisruption" list="disruptOptions" placeholder="Denied Wing Entry, Deflected Pass">
        </div>

        <div class="tag-field">
          <span class="tag-label">Defensive Breakdown</span>
          <input class="tag-input" id="defBreakdown" placeholder="Yes(Late Switch/Stuck/Etc.)">
        </div>

        <div class="tag-field">
          <span class="tag-label">Play Result</span>
          <input class="tag-input" id="playResult" list="resultOptions" placeholder="Missed FG / Live-Ball Turnover / ...">
        </div>

 <div class="tag-field">
  <span class="tag-label">Paint Touches</span>
  <input
    class="tag-input"
    id="paintTouches"
    list="paintTouchesOptions"
    placeholder="No Paint Touch / Drive / Post Touch / Cut"
  >
</div>

        <div class="tag-field">
          <span class="tag-label">Shooter Designation</span>
          <input class="tag-input" id="shooterDesignation" placeholder="Blue / Green / Black">
        </div>

        <div class="tag-field">
          <span class="tag-label">Shot Location</span>
          <input class="tag-input" id="shotLocation" list="shotLocOptions" placeholder="At Rim / Corner 3 / ...">
        </div>


        <div class="tag-field">
          <span class="tag-label">Shot Contest</span>
          <input class="tag-input" id="shotContest" list="contestOptions" placeholder="Open / Contested / Blocked">
        </div>

        <div class="tag-field narrow">
          <span class="tag-label">Rebound Outcome</span>
          <input class="tag-input" id="reboundOutcome" list="reboundOptions" placeholder="DREB / OREB / Other">
        </div>

        <div class="tag-field narrow">
          <span class="tag-label">Points</span>
          <input class="tag-input" id="points" type="number" min="0" max="3" value="0">
        </div>

        <div class="tag-field" style="min-width:260px">
          <span class="tag-label">Notes</span>
          <input class="tag-input" id="notes" placeholder="Any quick notes">
        </div>
      </div>

      <!-- Datalists -->
      <datalist id="locationOptions">
        <option>Home</option><option>Away</option><option>Neutral</option>
      </datalist>

      <datalist id="situationOptions">
        <option>Half Court</option><option>SLOB</option><option>BLOB</option>
        <option>Transition</option><option>Early Offense</option><option>Half Court (ATO)</option>
      </datalist>

      <datalist id="scoutOptions">
        <option>Yes – Practiced</option><option>Partial – Similar Action</option><option>No – Not Practiced</option>
      </datalist>

      <datalist id="coverageOptions">
        <option>Man</option><option>2-3</option><option>3-2</option>
        <option>1-3-1</option><option>1-2-2</option>
        <option>Full Court Man</option><option>2-2-1 Press</option><option>1-2-1-1 Press (Diamond)</option>
      </datalist>

      <datalist id="ballScreenOptions">
        <option>Under </option><option>Over </option><option>ICE </option>
        <option>Weak (Force Weak Hand)</option><option>Switch</option>
        <option>Hard Hedge</option><option>Soft Hedge/Show</option>
        <option>Peel Switch</option><option>Blitz (Trap)</option>
      </datalist>

      <datalist id="offBallOptions">
        <option>Attach/Stay</option><option>Over</option><option>Under</option>
        <option>Top-Lock</option><option>Switch</option><option>Show</option>
      </datalist>

      <datalist id="helpOptions">
        <option>No Help / No Rotation</option><option>Low-Man Help</option>
        <option>X-Out Rotation</option><option>Sink / Fill</option>
        <option>Full Rotation</option><option>Late Help</option>
        <option>No Rotation (Missed)</option><option>Peel Help</option>
      </datalist>

      <datalist id="disruptOptions">
        <option>Denied Wing Entry</option><option>Denied Post Entry</option>
        <option>Pressured Ball Handler to Prevent Pass</option><option>Deflected Pass</option>
      </datalist>

      <datalist id="resultOptions">
        <option>Made FG</option><option>Missed FG</option><option>And-One</option>
        <option>Live-Ball Turnover</option><option>Dead-Ball Turnover</option>
        <option>Turnover (Shot Clock Violation)</option><option>Shooting Foul</option>
        <option>Off-Ball Foul</option><option>Reach-In Foul</option>
       <option>Loose-Ball Foul</option><option>Deflection (Out of Bounds)</option>
      </datalist>

	<datalist id="paintTouchesOptions">
  <option>No Paint Touch</option>
  <option>Drive Baseline</option>
  <option>Drive Middle</option>
  <option>Post Touch - Low Block</option>
  <option>Post Touch - High Post</option>
  <option>Cut to Paint (Received Pass)</option>
</datalist>

      <datalist id="shotLocOptions">
        <option>At Rim (0–4 ft)</option><option>Paint (5–10 ft)</option>
        <option>Short Midrange (11–14 ft)</option><option>Long Midrange (15–20 ft)</option>
        <option>Corner 3 (21 ft 6 in)</option><option>Wing/Top 3 (22–23 ft)</option>
        <option>Deep 3 (24–26 ft)</option><option>Late Clock / Heave (27 ft +)</option>
      </datalist>

      <datalist id="contestOptions">
        <option>Open (4+ ft)</option><option>Light Contest / Late High-Hand (2–4 ft)</option>
        <option>Contested/On-Time High-Hand (1–2 ft)</option><option>Heavy Contest / Early High-Hand (0–1 ft)</option>
        <option>Blocked</option>
      </datalist>

      <datalist id="reboundOptions">
        <option>DREB</option><option>OREB</option><option>Other</option>
      </datalist>
    </section>
    <!-- ===================== END TAGS / CATEGORIES ===================== -->

  </div>
</main>

<button id="drawerTab" class="drawer-tab">Clips (0) ▴</button>
<section id="drawer" class="drawer hidden">
  <div class="drawer-head">
    <div class="flex items-center gap-3">
      <strong>Clip Queue</strong>
      <span id="queueMeta" class="muted">0 clips</span>
    </div>
    <div class="flex items-center gap-2">
      <button id="excelStatus" class="excel-btn inactive" type="button">Inactive</button>
      <button id="exportCsv" class="bg-neutral-800 hover:bg-neutral-700 px-3 py-1.5 rounded text-xs">Export CSV</button>
      <button id="addToDashboard" class="bg-emerald-600 hover:bg-emerald-500 px-3 py-1.5 rounded text-xs text-white">Add to Dashboard</button>
      <button id="toggleDrawer" class="bg-neutral-800 hover:bg-neutral-700 px-3 py-1.5 rounded text-xs">Close</button>
    </div>
  </div>
  <div class="px-4 pt-2 pb-1 text-xs text-slate-400" id="dashboardStatus" style="min-height:18px;"></div>
  <div class="drawer-body">
    <table class="queue-table">
    <colgroup>
  <col style="width:42px">   <!-- Select -->
  <col style="width:50px">   <!-- # -->
  <col style="width:55px">   <!-- Q -->
  <col style="width:65px">   <!-- Poss -->
  <col style="width:100px">  <!-- Start -->
  <col style="width:100px">  <!-- End -->
  <col style="width:170px">  <!-- Play -->
  <col style="width:160px">  <!-- Situation -->
  <col style="width:190px">  <!-- Shooter Designation -->
  <col style="width:170px">  <!-- Play Result -->
  <col style="width:70px">   <!-- Shot -->
  <col style="width:85px">   <!-- Delete -->
</colgroup>
      <thead>
        <tr>
          <th class="center"><input type="checkbox" id="queueSelectAll" checked></th>
          <th class="center">#</th><th class="center">Q</th><th class="center">Poss</th>
          <th>Start</th><th>End</th><th>Play</th><th>Situation</th><th>Shooter Designation</th>
          <th>Play Result</th><th class="center">Shot</th><th class="center">Delete</th>
        </tr>
      </thead>
      <tbody id="queueBody">
        <tr><td colspan="12" class="text-center text-slate-400 py-3">No clips yet.</td></tr>
      </tbody>
    </table>
  </div>
</section>

<div id="rowModal" class="modal-overlay">
  <div class="modal-box">
    <div class="modal-title">Choose Excel Row</div>
    <div style="color:#94a3b8; font-size:13px; margin-bottom:12px;">
      Enter the row number where you want to save this clip
    </div>
    <input type="number" id="rowInput" class="modal-input" placeholder="Row number (e.g., 2)" value="2" min="2">
    <div class="modal-btns">
      <button id="rowCancel" class="modal-btn secondary">Cancel</button>
      <button id="rowConfirm" class="modal-btn primary">Save to Row</button>
    </div>
  </div>
</div>

<script>
/* ------------ Utilities ------------ */
const fmt=(s)=>{const h=Math.floor(s/3600),m=Math.floor((s%3600)/60),ss=Math.floor(s%60);return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(ss).padStart(2,'0')}`};

let excelActive = false;
let pendingClipData = null;
// Make clips truly global
window.clips = Array.isArray(window.clips) ? window.clips : [];
const clips = window.clips;


/* ------------ Video setup ------------ */
const v=document.getElementById('video'), src=document.getElementById('videoSrc');
let currentVideoFile = null;
let currentVideoPath = null;

const EXTRACTOR_URL = 'http://127.0.0.1:5002';
const LocationAPI = window.LocationUtils || {};
const LOCATION_MAP_KEY = LocationAPI.LOCATION_MAP_KEY || 'ou_wbb_game_location_map';

const standardizeLocation = LocationAPI.standardizeLocation || function (value) {
  const raw = (value ?? '').toString().trim().toLowerCase();
  if (!raw) return '';
  if (raw.includes('neutral')) return 'neutral';
  if (raw === 'away' || raw.includes('away') || raw === 'road' || raw.includes('road')) return 'away';
  if (raw === 'home' || raw.includes('home')) return 'home';
  return raw;
};

const cacheGameLocation = LocationAPI.cacheGameLocation || function (keys, locationCode, locationDisplay) {
  const validKeys = (Array.isArray(keys) ? keys : [keys])
    .map((key) => String(key || ''))
    .filter(Boolean);
  if (!validKeys.length) return;
  const payload = {
    code: locationCode || '',
    display: locationDisplay || ''
  };
  try {
    const existing = JSON.parse(localStorage.getItem(LOCATION_MAP_KEY) || '{}');
    validKeys.forEach((key) => {
      existing[key] = payload;
    });
    localStorage.setItem(LOCATION_MAP_KEY, JSON.stringify(existing));
  } catch (err) {
    console.warn('Unable to cache game location', err);
  }
};

const formatLocationLabel = LocationAPI.formatLocationLabel || function (code) {
  const normalized = standardizeLocation(code);
  if (normalized === 'home') return 'HOME';
  if (normalized === 'away') return 'AWAY';
  if (normalized === 'neutral') return 'NEUTRAL';
  return normalized ? normalized.toUpperCase() : '—';
};

const resolveCachedLocation = LocationAPI.resolveCachedLocation || function (keysOrClip) {
  const keys = [];
  if (!keysOrClip) return null;
  if (typeof keysOrClip === 'object') {
    const clip = keysOrClip;
    keys.push(
      clip.__gameId,
      clip.gameId,
      clip.game_id,
      clip.game_num,
      clip['Game #'],
      clip.gameNumber,
      clip.id && `clip:${clip.id}`
    );
  } else if (Array.isArray(keysOrClip)) {
    keys.push(...keysOrClip);
  } else {
    keys.push(keysOrClip);
  }
  try {
    const existing = JSON.parse(localStorage.getItem(LOCATION_MAP_KEY) || '{}');
    for (const key of keys) {
      if (!key) continue;
      const payload = existing[String(key)];
      if (payload && (payload.code || payload.display)) return payload;
    }
  } catch (err) {
    console.warn('Unable to read cached locations', err);
  }
  return null;
};

const DASHBOARD_STORAGE_KEY = 'ou_wbb_selected_clips';

function ensureLocationSnapshot(clip) {
  if (!clip) return { code: '', display: '' };
  const display =
    clip.Location ||
    clip.location_display ||
    clip.locationDisplay ||
    clip['Location'] ||
    clip['Game Location'] ||
    '';
  const code =
    clip.location ||
    clip.location_code ||
    clip.locationCode ||
    clip.game_location ||
    clip.gameLocation ||
    standardizeLocation(display);
  const cached = resolveCachedLocation(clip) || {};
  const finalCode = standardizeLocation(code || cached.code || display);
  const finalDisplay = display || cached.display || formatLocationLabel(finalCode);
  return { code: finalCode, display: finalDisplay };
}

function buildServerPayload(clipData) {
  const normalized = toNormalizedPayload(clipData);
  const { code, display } = ensureLocationSnapshot(clipData);
  return {
    id: clipData.__clipId,
    __clipId: clipData.__clipId,
    __gameId: clipData.__gameId,
    __opponent: clipData.__opponent,
    gameId: clipData.__gameId,
    game_id: clipData.__gameId,
    game_num: clipData['Game #'],
    opponent: clipData['Opponent'],
    quarter: clipData['Quarter'],
    possession: clipData['Possession #'],
    situation: clipData['Situation'],
    formation: clipData['Offensive Formation'],
    playName: clipData['Play Name'],
    scoutCoverage: clipData['Covered in Scout?'],
    actionTrigger: clipData['Action Trigger'],
    actionTypes: clipData['Action Type(s)'],
    actionSequence: clipData['Action Sequence'],
    coverage: clipData['Defensive Coverage'],
    ballScreen: clipData['Ball Screen Coverage'],
    offBallScreen: clipData['Off-Ball Screen Coverage'],
    helpRotation: clipData['Help/Rotation'],
    disruption: clipData['Defensive Disruption'],
    breakdown: clipData['Defensive Breakdown'],
    result: clipData['Play Result'],
    paintTouch: clipData['Paint Touches'],
    shooter: clipData['Shooter Designation'],
    shotLocation: clipData['Shot Location'],
    contest: clipData['Shot Contest'],
    rebound: clipData['Rebound Outcome'],
    hasShot: clipData['Has Shot'],
    shotX: clipData['Shot X'],
    shotY: clipData['Shot Y'],
    shotResult: clipData['Shot Result'],
    notes: clipData['Notes'],
    startTime: clipData['Start Time'],
    endTime: clipData['End Time'],
    filename: clipData.filename || (currentVideoFile?.name || ''),
    video_path: clipData.video_path || currentVideoPath || '',
    location: code,
    location_code: code,
    locationCode: code,
    location_display: display,
    locationDisplay: display,
    locationLabel: formatLocationLabel(code || display),
    game_location: code,
    gameLocation: code,
    'Game Location': display,
    savedAt: new Date().toISOString(),
    normalized
  };
}

async function persistClipToServer(clipData) {
  try {
    const payload = buildServerPayload(clipData);
    const response = await fetch('http://127.0.0.1:8000/api/clips', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      throw new Error(`Server responded with ${response.status}`);
    }
    const statusEl = document.getElementById('dashboardStatus');
    if (statusEl) statusEl.textContent = 'Clip saved to library.';
    return true;
  } catch (err) {
    console.warn('Persist clip error', err);
    setDashboardStatus('Saved locally. Dashboard sync unavailable.', 'warn');
    return false;
  }
}

function stageClipForDashboard(clipsToStage = []) {
  if (!Array.isArray(clipsToStage) || !clipsToStage.length) return;
  let existing = [];
  try {
    existing = JSON.parse(localStorage.getItem(DASHBOARD_STORAGE_KEY) || '[]');
  } catch (_) {
    existing = [];
  }
  const byId = new Map((existing || []).map((clip) => [clip.id || clip.__clipId || clip.__gameId, clip]));
  clipsToStage.forEach((clip) => {
    const normalized = {
      ...clip,
      ...toNormalizedPayload(clip)
    };
    normalized.id = normalized.id || clip.__clipId || clip.id || `${clip['Game #']}_${clip['Quarter']}_${clip['Possession #']}`;
    const { code, display } = ensureLocationSnapshot(clip);
    normalized.location = code || normalized.location;
    normalized.location_display = display || normalized.location_display;
    normalized.location_code = code || normalized.location_code;
    normalized.Location = display || normalized.Location;
    byId.set(normalized.id, normalized);
  });
  const next = Array.from(byId.values());
  try {
    localStorage.setItem(DASHBOARD_STORAGE_KEY, JSON.stringify(next));
    setDashboardStatus(`${clipsToStage.length} clip${clipsToStage.length === 1 ? '' : 's'} staged for dashboard.`, 'info');
  } catch (err) {
    console.error('Unable to stage clips for dashboard', err);
  }
}

function downloadCsv(filename, content) {
  try {
    const blob = new Blob([content], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  } catch (err) {
    console.error('CSV download error', err);
  }
}

document.getElementById('loadBtn').addEventListener('click',()=>document.getElementById('videoInput').click());
document.getElementById('videoInput').addEventListener('change', async (e) => {
  const f = e.target.files?.[0];
  if (!f) return;

  currentVideoFile = f;
  currentVideoPath = f.path || f.name; // file.path works in some browsers/Electron

  src.src = URL.createObjectURL(f);
  v.controls = true;
  v.preload = 'metadata';
  v.load();
  v.addEventListener('loadedmetadata', () => { try { v.currentTime = 0; } catch(_) {} }, { once: true });

  // Send video path to backend
  try {
    await fetch(`${EXTRACTOR_URL}/set_video`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({
        video_path: currentVideoPath,
        filename: f.name
      })
    });
  } catch(err) {
    console.warn('Could not connect to clip extractor:', err);
  }
});
const overlay=document.getElementById('overlay');
document.getElementById('playOverlay').addEventListener('click',()=>v.play());
v.addEventListener('play',()=>overlay.classList.add('hidden'));
v.addEventListener('pause',()=>overlay.classList.remove('hidden'));
v.addEventListener('loadedmetadata',()=>overlay.classList.remove('hidden'));

document.querySelectorAll('[data-speed]').forEach(b=>b.addEventListener('click',()=>v.playbackRate=parseFloat(b.dataset.speed||'1')));
document.querySelectorAll('[data-skip]').forEach(b=>b.addEventListener('click',()=>{v.currentTime=Math.max(0,v.currentTime+parseFloat(b.dataset.skip||'0'));}));
document.getElementById('ppBtn').addEventListener('click',()=>{v.paused?v.play():v.pause();});

document.addEventListener('keydown', (e)=>{
  const isTyping = e.target.closest('input, textarea, [contenteditable], [contenteditable="true"]');
  if ((e.key === ' ' || e.code === 'Space') && !isTyping){ e.preventDefault(); v.paused ? v.play() : v.pause(); }
  if (e.key.toLowerCase() === 'k' && !isTyping){ e.preventDefault(); v.paused ? v.play() : v.pause(); }
});

const IN=document.getElementById('inTime'), OUT=document.getElementById('outTime');
document.getElementById('markIn').addEventListener('click',()=>{ if(!isNaN(v.currentTime)) IN.value=fmt(v.currentTime); });
document.getElementById('markOut').addEventListener('click',()=>{ if(!isNaN(v.currentTime)) OUT.value=fmt(v.currentTime); });

/* ------------ Excel bridge ------------ */
async function toggleExcel() {
  const statusEl = document.getElementById('excelStatus');
  if (!excelActive) {
    try {
      const resp = await fetch('http://127.0.0.1:5000/start', { method: 'POST' });
      const data = await resp.json();
      if (data.ok) {
        excelActive = true;
        statusEl.textContent = 'Active';
        statusEl.classList.remove('inactive'); statusEl.classList.add('active');
      } else {
        alert('Failed to start Excel bridge: ' + (data.info || 'Unknown error'));
      }
    } catch (err) {
      alert('Could not connect to bridge controller.\n\nOpen Terminal and paste this command:\n\ncd ~/Desktop/"OU Analytics"/Python && python3 bridge_controller.py\n\nThen refresh this page and click Active again.');
    }
  } else {
    try {
      const resp = await fetch('http://127.0.0.1:5000/stop', { method: 'POST' });
      const data = await resp.json();
      if (data.ok) {
        excelActive = false;
        statusEl.textContent = 'Inactive';
        statusEl.classList.remove('active'); statusEl.classList.add('inactive');
      } else {
        alert('Failed to stop Excel bridge');
      }
    } catch (err) {
      console.error('Error stopping bridge:', err);
      alert('Could not stop Excel bridge');
    }
  }
}
document.getElementById('excelStatus').addEventListener('click', toggleExcel);

async function sendToExcel(clipData, targetRow) {
  try {
    const checkResp = await fetch(`http://127.0.0.1:5001/check_row?row=${targetRow}`);
    if (checkResp.ok) {
      const checkResult = await checkResp.json();
      if (checkResult.has_data) {
        const confirmed = confirm(`⚠️ Row ${targetRow} already has data. Overwrite?`);
        if (!confirmed) return;
      }
    }
    const resp = await fetch('http://127.0.0.1:5001/append', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ...clipData, Target_Row: targetRow, Overwrite: true })
    });
    const result = await resp.json();
    if (result.ok) alert(`✅ Saved to Excel at row ${result.row}!`);
    else alert('Error saving to Excel: ' + (result.error || 'Unknown error'));
  } catch (err) {
    console.error('Excel save error:', err);
    alert('Could not save to Excel. Error: ' + err.message);
  }
}
function showRowModal(clipData) {
  pendingClipData = clipData;
  document.getElementById('rowModal').classList.add('show');
  document.getElementById('rowInput').focus();
}
function hideRowModal() {
  document.getElementById('rowModal').classList.remove('show');
  pendingClipData = null;
}
document.getElementById('rowCancel').addEventListener('click', hideRowModal);
document.getElementById('rowConfirm').addEventListener('click', async () => {
  const rowNum = parseInt(document.getElementById('rowInput').value) || 2;
  if (pendingClipData) {
    const dataToSend = pendingClipData;
    hideRowModal();
    await sendToExcel(dataToSend, rowNum);
  } else {
    hideRowModal();
  }
});

/* ------------ Save + Queue ------------ */
document.getElementById('save').addEventListener('click', async ()=>{
  if(!IN.value||!OUT.value) return alert('Mark IN and OUT first');

  // Check for duplicate possession
  const checkGameNum = document.getElementById('gameNum').value;
  const checkOpponent = document.getElementById('opponent').value;
  const checkQuarter = document.getElementById('quarter').value;
  const checkPossession = document.getElementById('possession').value;

  const duplicate = clips.find(c =>
    c['Game #'] === checkGameNum &&
    c['Opponent'] === checkOpponent &&
    c['Quarter'] === checkQuarter &&
    c['Possession #'] === checkPossession
  );

  if (duplicate) {
    const confirmOverwrite = confirm(
      'WARNING: Duplicate Possession Detected!\n\n' +
      'Game ' + checkGameNum + ' vs ' + checkOpponent + ', Q' + checkQuarter + ' P' + checkPossession + ' already exists in the queue.\n\n' +
      'Click OK to save anyway (will create duplicate)\n' +
      'Click Cancel to go back and change the possession number'
    );
    if (!confirmOverwrite) return;
  }

  const includeShotEl = document.getElementById('includeShot');
  const includeShot = !!includeShotEl?.checked;
  const shotXInput = document.getElementById('shotX');
  const shotYInput = document.getElementById('shotY');
  const shotResultInput = document.getElementById('shotResultPicker');
  const shotDesigInput = document.getElementById('shotDesigPicker');
  const shotXVal = includeShot ? (shotXInput?.value || '') : '';
  const shotYVal = includeShot ? (shotYInput?.value || '') : '';
  const shotResultVal = includeShot ? (shotResultInput?.value || '') : '';

  // Use shot picker designation if set, otherwise fall back to main shooter designation
  const mainShooterDesig = document.getElementById('shooterDesignation').value;
  const shotDesigVal = includeShot && shotDesigInput?.value ? shotDesigInput.value : mainShooterDesig;

  const locationDisplay = document.getElementById('gameLocation')?.value || '';
  const locationCode = standardizeLocation(locationDisplay);

  const clipData = {
    'Game #': document.getElementById('gameNum').value,
    'Location': locationDisplay,
    'Opponent': document.getElementById('opponent').value,
    'Game Location': locationDisplay,
    'Location Code': locationCode,
    'Quarter': document.getElementById('quarter').value,
    'Possession #': document.getElementById('possession').value,
    'Situation': document.getElementById('situation').value,
    'Offensive Formation': document.getElementById('offFormation').value,
    'Play Name': document.getElementById('playName').value,
    'Covered in Scout?': document.getElementById('scoutTag').value,
    'Action Trigger': document.getElementById('actionTrigger').value,
    'Action Type(s)': document.getElementById('actionTypes').value,
    'Action Sequence': document.getElementById('actionSeq').value,
    'Defensive Coverage': document.getElementById('coverage').value,
    'Ball Screen Coverage': document.getElementById('ballScreenCov').value,
    'Off-Ball Screen Coverage': document.getElementById('offBallScreenCov').value,
    'Help/Rotation': document.getElementById('helpRotation').value,
    'Defensive Disruption': document.getElementById('defDisruption').value,
    'Defensive Breakdown': document.getElementById('defBreakdown').value,
    'Play Result': document.getElementById('playResult').value,
    'Paint Touches': document.getElementById('paintTouches').value,
    'Shooter Designation': shotDesigVal,
    'Shot Location': document.getElementById('shotLocation').value,
    'Has Shot': includeShot ? 'Yes' : 'No',
    'Shot X': shotXVal,
    'Shot Y': shotYVal,
    'Shot Result': shotResultVal,
    'Shot Contest': document.getElementById('shotContest').value,
    'Shot Quality': document.getElementById('shotQuality')?.value || '',
    'Rebound Outcome': document.getElementById('reboundOutcome').value,
    'Points': document.getElementById('points').value,
    'Notes': document.getElementById('notes').value,
    'Start Time': IN.value,
    'End Time': OUT.value
  };

  // === Canonical game/clip IDs to prevent cross-game mixing ===
  const opponentRaw = (clipData['Opponent'] || '').trim();
  const gameNum     = parseInt(clipData['Game #'], 10) || 0;
  const slug = s => s.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g,'');

  // Stable game key, e.g. G1_iowa, G2_texas, etc.
  const gameId = `G${gameNum}_${slug(opponentRaw)}`;

  // Unique clip id for lookups in detail page if needed
  const clipId = `${gameId}_Q${clipData['Quarter']}P${clipData['Possession #']}_${Date.now().toString().slice(-6)}`;

  // Attach system fields used by the dashboard / library
  clipData.__gameId   = gameId;
  clipData.__clipId   = clipId;
  clipData.__opponent = opponentRaw;
  clipData.id = clipId;
  clipData.gameId = gameId;
  clipData.game_id = gameId;
  clipData.game_num = clipData['Game #'];
  clipData.filename = clipData.filename || currentVideoFile?.name || '';
  clipData.video_path = clipData.video_path || currentVideoPath || '';
  clipData.location = locationCode || locationDisplay || '';
  clipData.game_location = locationCode || locationDisplay || '';
  clipData.gameLocation = locationCode || locationDisplay || '';
  clipData.location_display = locationDisplay;
  clipData.locationDisplay = locationDisplay;
  clipData.location_code = locationCode;
  clipData.locationCode = locationCode;
  clipData.__location = locationCode || locationDisplay;
  clipData.__locationDisplay = locationDisplay;
  clipData.__locationCode = locationCode;

  const cacheKeys = [
    clipData.__gameId,
    clipData['Game #'],
    `num:${clipData['Game #']}`,
    clipData['Game #'] && opponentRaw ? `num:${clipData['Game #']}:${slug(opponentRaw)}` : null
  ];
  cacheGameLocation(cacheKeys, locationCode, locationDisplay);

  window.clipData = clipData;
  window._lastClipData = { ...clipData };

// Build the queue fields you already show
const queueBits = {
  q: clipData['Quarter'],
  p: clipData['Possession #'],
  start: IN.value,
  end: OUT.value,
  play: clipData['Play Name'],
  situation: clipData['Situation'],
  shooter: clipData['Shooter Designation'],
  res: clipData['Play Result']
};

// Save ONE object that includes everything (queue + full tags)
const queueEntry = { ...clipData, ...queueBits, __selected: true };
clips.push(queueEntry);

persistClipToServer(clipData);
stageClipForDashboard([clipData]);


// === Excel Bridge: send directly to chosen row ===
if (excelActive) {
  const inlineRowEl = document.getElementById('rowInline');
  const rowNum = Math.max(2, parseInt(inlineRowEl?.value, 10) || 2);
  await sendToExcel(clipData, rowNum);      // existing function in your file
  inlineRowEl.value = String(rowNum + 1);   // optional: auto-advance next row
}
// === End Excel Bridge ===

// === CLEAR TAGS (keep Opponent & Quarter; bump Possession) ===
try {
  // bump Possession +1
  const possEl = document.getElementById('possession');
  if (possEl) possEl.value = String((parseInt(possEl.value, 10) || 0) + 1);

  // clear every tag input except Opponent, Quarter, Possession
  document.querySelectorAll('#tagRow .tag-input').forEach(el => {
    const id = el.id || '';
  if (['gameNum','gameLocation','opponent','quarter','possession'].includes(id)) return;
    // reset Points to 0; everything else blank
    if (id === 'points') el.value = '0';
    else el.value = '';
  });

  // clear IN / OUT boxes (use the elements directly to avoid scope issues)
  document.getElementById('inTime').value  = '';
  document.getElementById('outTime').value = '';

  // optional: put cursor back in Play Name
} catch (e) {
  console.error('Clear-after-save error:', e);
}
// === END CLEAR TAGS ===

try{
  const sx = document.getElementById('shotX');
  const sy = document.getElementById('shotY');
  if (sx && sy){ sx.value=''; sy.value=''; }
} catch(_){ }

  renderQueue();
});

/* ------------ Add Selected Clips to Dashboard ------------ */
const dashboardStatusEl = document.getElementById('dashboardStatus');
const addToDashboardBtn = document.getElementById('addToDashboard');

function setDashboardStatus(message, tone = 'muted') {
  if (!dashboardStatusEl) return;
  dashboardStatusEl.textContent = message || '';
  const palette = {
    success: '#22c55e',
    warn: '#fbbf24',
    error: '#f87171',
    info: '#38bdf8',
    muted: '#94a3b8'
  };
  dashboardStatusEl.style.color = palette[tone] || palette.muted;
}

function getSelectedCount() {
  return clips.reduce((count, clip) => count + (clip.__selected === false ? 0 : 1), 0);
}
// --- Normalize Tagger fields to Dashboard schema before sending ---
function toNormalizedPayload(clip) {
  const snapshot = ensureLocationSnapshot(clip);
  const locationDisplay = snapshot.display;
  const locationCode = snapshot.code;

  return {
    id: clip.__clipId || clip.id || `${clip['Game #'] || ''}_${clip['Quarter'] || ''}_${clip['Possession #'] || ''}`,
    game: String(clip['Game #'] || ''),
    opponent: clip['Opponent'] || '',
    quarter: String(clip['Quarter'] || ''),
    possession: String(clip['Possession #'] || ''),
    location: locationCode || locationDisplay,
    location_display: locationDisplay,
    location_code: locationCode || '',
    situation: clip['Situation'] || '',
    offensive_formation: clip['Offensive Formation'] || '',
    play_name: clip['Play Name'] || '',
    scout_coverage: clip['Covered in Scout?'] || '',
    action_trigger: clip['Action Trigger'] || '',
    action_types: clip['Action Type(s)'] || '',
    action_sequence: clip['Action Sequence'] || '',
    defensive_coverage: clip['Defensive Coverage'] || '',
    ball_screen_coverage: clip['Ball Screen Coverage'] || '',
    off_ball_screen_coverage: clip['Off-Ball Screen Coverage'] || '',
    help_rotation: clip['Help/Rotation'] || '',
    defensive_disruption: clip['Defensive Disruption'] || '',
    defensive_breakdown: clip['Defensive Breakdown'] || '',
    result: clip['Play Result'] || '',
    paint_touches: clip['Paint Touches'] || '',
    shooter_designation: clip['Shooter Designation'] || '',
    shot_location: clip['Shot Location'] || '',
    shot_contest: clip['Shot Contest'] || '',
    rebound_outcome: clip['Rebound Outcome'] || '',
    points: clip['Points'] || '0',
    notes: clip['Notes'] || '',
    start_time: clip['Start Time'] || '',
    end_time: clip['End Time'] || '',
    filename: (window.currentVideoPath || window.currentVideoFile?.name || ''),
  };
}

async function sendClipToExtractor(clipData) {
  // Build a payload that includes BOTH your original Tagger keys
  // AND the snake_case keys many backends expect. Also pass the video path.
  const locationDisplay =
    clipData['Location'] ??
    clipData.Location ??
    clipData.location_display ??
    clipData.locationDisplay ??
    clipData['Game Location'] ??
    clipData.gameLocation ??
    '';
  const locationCode = standardizeLocation(
    clipData.location ??
    clipData.location_code ??
    clipData.locationCode ??
    locationDisplay
  );

  const payload = {
    ...clipData,
    Location: locationDisplay,
    location: locationCode || locationDisplay,
    location_display: locationDisplay,
    location_code: locationCode || '',
    game_location: locationCode || locationDisplay || '',
    gameLocation: locationCode || locationDisplay || '',

    // strong hints for the backend
    filename: (window.currentVideoFile?.name || ''),
    video_path: (window.currentVideoPath || ''),

    // snake_case mirrors (keeps “the way it was” while adding a normalized copy)
    game: String(clipData['Game #'] ?? ''),
    opponent: clipData['Opponent'] ?? '',
    quarter: String(clipData['Quarter'] ?? ''),
    possession: String(clipData['Possession #'] ?? ''),
    situation: clipData['Situation'] ?? '',
    offensive_formation: clipData['Offensive Formation'] ?? '',
    play_name: clipData['Play Name'] ?? '',
    scout_coverage: clipData['Covered in Scout?'] ?? '',
    action_trigger: clipData['Action Trigger'] ?? '',
    action_types: clipData['Action Type(s)'] ?? '',
    action_sequence: clipData['Action Sequence'] ?? '',
    defensive_coverage: clipData['Defensive Coverage'] ?? '',
    ball_screen_coverage: clipData['Ball Screen Coverage'] ?? '',
    off_ball_screen_coverage: clipData['Off-Ball Screen Coverage'] ?? '',
    help_rotation: clipData['Help/Rotation'] ?? '',
    defensive_disruption: clipData['Defensive Disruption'] ?? '',
    defensive_breakdown: clipData['Defensive Breakdown'] ?? '',
    result: clipData['Play Result'] ?? '',
    paint_touches: clipData['Paint Touches'] ?? '',
    shooter_designation: clipData['Shooter Designation'] ?? '',
    shot_location: clipData['Shot Location'] ?? '',
    shot_contest: clipData['Shot Contest'] ?? '',
    rebound_outcome: clipData['Rebound Outcome'] ?? '',
    points: clipData['Points'] ?? '0',
    notes: clipData['Notes'] ?? '',
    start_time: clipData['Start Time'] ?? '',
    end_time: clipData['End Time'] ?? ''
  };

  let response, text, result = {};
  try {
    response = await fetch(`${EXTRACTOR_URL}/extract_clip`, {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify(payload)
    });
    text = await response.text();
    try { result = JSON.parse(text); } catch { result = {}; }
  } catch (netErr) {
    // Network error (server not running / CORS / refused)
    throw new Error(`Network error talking to extractor at ${EXTRACTOR_URL}/extract_clip — ${String(netErr)}`);
  }

  if (!response.ok || (result && result.ok === false)) {
    const msg = (result && result.error) ? result.error : (text || `HTTP ${response.status}`);
    throw new Error(msg);
  }

  // Optional: persist locally so the dashboard fallback (if you ever use it) can see clips
  try {
    const key = 'ou_clips_v1';
    const gid = String(payload.game||'').trim();
    const q   = String(payload.quarter||'').trim();
    const p   = String(payload.possession||'').trim();
    const id  = `G${gid}Q${q}P${p}`;
    const norm = { id, ...payload };
    const arr = JSON.parse(localStorage.getItem(key) || '[]');
    const i = arr.findIndex(x => x.id === id);
    if (i >= 0) arr[i] = norm; else arr.push(norm);
    localStorage.setItem(key, JSON.stringify(arr));
  } catch {}

  return result || { ok: true };
}

addToDashboardBtn?.addEventListener('click', async () => {
  if (!currentVideoFile) {
    setDashboardStatus('Load a video before adding clips.', 'warn');
    return;
  }

  if (!clips.length) {
    setDashboardStatus('No clips in the queue yet.', 'warn');
    return;
  }

  const selectedClips = clips.filter(c => c.__selected !== false);
  if (!selectedClips.length) {
    setDashboardStatus('Select at least one clip to add.', 'warn');
    return;
  }

  const originalLabel = addToDashboardBtn.textContent;
  addToDashboardBtn.disabled = true;
  addToDashboardBtn.textContent = 'Adding...';
  setDashboardStatus(`Adding ${selectedClips.length} clip${selectedClips.length > 1 ? 's' : ''}...`, 'info');

  let successCount = 0;
  let failureCount = 0;

  for (const clip of selectedClips) {
    if (!clip['Start Time'] || !clip['End Time']) {
      failureCount++;
      console.warn('Skipping clip missing timestamps', clip);
      continue;
    }
    try {
      await sendClipToExtractor(clip);
      successCount++;
    } catch (err) {
      failureCount++;
      console.error('Add to dashboard failed:', err);
    }
  }

  addToDashboardBtn.disabled = false;
  addToDashboardBtn.textContent = originalLabel;

  if (successCount && !failureCount) {
    setDashboardStatus(`Added ${successCount} clip${successCount > 1 ? 's' : ''} to dashboard.`, 'success');
  } else if (successCount && failureCount) {
    setDashboardStatus(`Added ${successCount} clip${successCount > 1 ? 's' : ''}; ${failureCount} failed. Check console for details.`, 'warn');
  } else {
    setDashboardStatus('Could not add clips. Check console for details.', 'error');
  }
});

function updateQueueSelectAll() {
  const selectAll = document.getElementById('queueSelectAll');
  if (!selectAll) return;
  const total = clips.length;
  if (!total) {
    selectAll.checked = false;
    selectAll.indeterminate = false;
    return;
  }
  const selected = getSelectedCount();
  selectAll.checked = selected === total;
  selectAll.indeterminate = selected > 0 && selected < total;
}

function renderQueue(){
  const body=document.getElementById('queueBody');
  const tab=document.getElementById('drawerTab');
  const meta=document.getElementById('queueMeta');
  if(!body || !tab || !meta) return;

  if(!clips.length){
    body.innerHTML='<tr><td colspan="12" class="text-center text-slate-400 py-3">No clips yet.</td></tr>';
  } else {
    body.innerHTML = clips.map((c,i)=>{
      if (typeof c.__selected === 'undefined') c.__selected = true;
      const isChecked = c.__selected !== false;
      const rowClass = isChecked ? 'queue-row' : 'queue-row unselected';
      return `
      <tr class="${rowClass}" data-idx="${i}">
        <td class="center">
          <input type="checkbox" class="queue-select" data-idx="${i}" ${isChecked ? 'checked' : ''}>
        </td>
        <td class="center">${i+1}</td>
        <td class="center">${c.q}</td>
        <td class="center">${c.p}</td>
        <td>${c.start}</td>
        <td>${c.end}</td>
        <td>${c.play}</td>
        <td>${c.situation}</td>
        <td>${c.shooter}</td>
        <td>${c.res}</td>
        <td class="center queue-shot-cell" data-idx="${i}"></td>
        <td class="center"><button class="del-btn" data-del="${i}">Delete</button></td>
      </tr>
      `;
    }).join('');
  }

  const selectedCount = getSelectedCount();
  tab.textContent = `Clips (${clips.length}) ▴`;
  meta.textContent = clips.length
    ? `${clips.length} clip${clips.length>1?'s':''} - ${selectedCount} selected`
    : '0 clips';

  updateQueueSelectAll();

  if (typeof window.renderMiniShot === 'function') {
    requestAnimationFrame(()=>{
      body.querySelectorAll('.queue-shot-cell').forEach(cell=>{
        const idx = parseInt(cell.getAttribute('data-idx'),10);
        if (Number.isNaN(idx)) return;
        const clip = clips[idx];
        cell.innerHTML = '';
        if (!clip) return;
        if (clip['Has Shot'] === 'Yes' && clip['Shot X'] !== '' && clip['Shot Y'] !== '') {
          const x = parseFloat(clip['Shot X']);
          const y = parseFloat(clip['Shot Y']);
          if (!Number.isNaN(x) && !Number.isNaN(y)) {
            const desig = clip['Shooter Designation'] || 'Black';
            const res = (/made/i.test(clip['Play Result'] || '')) ? 'Made' : 'Missed';
    window.renderMiniShot(cell, x, y, desig, res);
          }
        }
      });
    });
  }
}

const queueBodyEl = document.getElementById('queueBody');
queueBodyEl.addEventListener('click', (e)=>{
  if (e.target.matches('.queue-select')) {
    const idx = parseInt(e.target.getAttribute('data-idx'), 10);
    if (!Number.isNaN(idx) && clips[idx]) {
      clips[idx].__selected = e.target.checked;
      renderQueue();
    }
    e.stopPropagation();
    return;
  }

  const del = e.target.getAttribute('data-del');
  if(del !== null){
    const idx = parseInt(del,10);
    if(!Number.isNaN(idx)){
      clips.splice(idx,1);
      renderQueue();
    }
    return;
  }
  const row = e.target.closest('.queue-row');
  if(!row) return;
  const idx = parseInt(row.getAttribute('data-idx'),10);
  if(Number.isNaN(idx)) return;
  const t = clips[idx]?.start;
  if(!t) return;
  const [H,M,S] = t.split(':').map(Number);
  v.currentTime = H*3600+M*60+S;
  v.pause();
});

document.getElementById('queueSelectAll').addEventListener('change', (e) => {
  const checked = e.target.checked;
  clips.forEach(c => { c.__selected = checked; });
  renderQueue();
});

renderQueue();

/* ------------ Drawer ------------ */
const drawer = document.getElementById('drawer');
function toggleDrawer() {
  const isHidden = drawer.classList.contains('hidden');
  if (isHidden) {
    drawer.classList.remove('hidden');
    requestAnimationFrame(() => drawer.classList.add('open'));
  } else {
    drawer.classList.remove('open');
    setTimeout(() => drawer.classList.add('hidden'), 220); // matches .22s transition
  }
}
document.getElementById('drawerTab').addEventListener('click', toggleDrawer);
document.getElementById('toggleDrawer').addEventListener('click', toggleDrawer);


/* ------------ PBP filter ------------ */
(function () {
  document.addEventListener('DOMContentLoaded', () => {
    const pbpTextEl = document.getElementById('pbpText');
    const filterBtn = document.getElementById('filterPBP');
    const clearBtn  = document.getElementById('clearPBP');
    const tabButtons = document.querySelectorAll('#pbpTabs .tab-btn');
    const panes = {
      filter: document.getElementById('pbpFilterPane'),
      shot: document.getElementById('shotPane')
    };

    filterBtn?.addEventListener('click', processPlayByPlay);
    clearBtn?.addEventListener('click', () => {
      if (confirm('Clear play-by-play text?')) pbpTextEl.value = '';
    });
    tabButtons.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const target = btn.dataset.tab;
        if (!target || !panes[target]) return;
        tabButtons.forEach(b=>b.classList.toggle('active', b===btn));
        Object.entries(panes).forEach(([key,pane])=>{
          pane?.classList.toggle('active', key===target);
        });
      });
    });
  });

  function processPlayByPlay() {
    const pbpTextEl = document.getElementById('pbpText');
    const raw = pbpTextEl?.value || '';
    if (!raw.trim()) { alert('Paste ESPN play-by-play first'); return; }

    const OU_FULL_NAMES = [
      'Raegan Beers','Aaliyah Chavez','Daffa Cissoko','Beatrice Culliton',
      'Keziah Lofton','Caya Smith','Brooklyn Stewart','Emma Tolan',
      'Zya Vann','Payton Verhulst','Sahara Williams',
      'Lexi Keys','Lexy Keys','Liz Scott','Skylar Vann','Jalynn Bristow',
      'Aubrey Joens','KK Rodriguez','Kennedy Tucker','Nevaeh Tot','Maya Nealy',
      'Reyna Scott'
    ];
    const OU_TEAM_WORDS = ['Oklahoma','OU','Sooners'];
    const hasFullOUName = d => OU_FULL_NAMES.some(n => new RegExp(`\\b${n}\\b`, 'i').test(d));
    const hasOUTeamWord = d => OU_TEAM_WORDS.some(w => new RegExp(`\\b${w}\\b`, 'i').test(d));

    const ACTION_RE = /\b(made|missed|free throw|turnover|steal|defensive rebound|offensive rebound|rebound|jump ball)\b/i;
    const isMade  = d => /\bmade\b/i.test(d) && !/\bmade free throw\b/i.test(d);
    const isThree = d => /\bthree point\b/i.test(d);
    const isFT    = d => /\bfree throw\b/i.test(d);
    const isMiss  = d => /\bmissed\b/i.test(d);
    const isTO    = d => /\bturnover\b/i.test(d) || /\bshot clock turnover\b/i.test(d);
    const isSteal = d => /\bsteal\b/i.test(d);
    const isDReb  = d => /\bdefensive rebound\b/i.test(d);
    const isOReb  = d => /\boffensive rebound\b/i.test(d);

    const classify = d => (hasFullOUName(d) || hasOUTeamWord(d)) ? 'OU'
                      : (ACTION_RE.test(d) ? 'OPP' : 'NEUTRAL');

    const isJumpBallToOpp = d =>
      /jump ball/i.test(d) &&
      /(won by|to)/i.test(d) &&
      !hasFullOUName(d) &&
      !hasOUTeamWord(d);

    const lines = raw.split('\n').map(l => l.replace(/\u00A0/g,' ').trim()).filter(Boolean);
    const timeRe = /(^|\s)(\d{1,2}:\d{2})(?=\s|$)|(^|\s)(\d:\d{2}:\d{2})(?=\s|$)/;
    const plays = [];
    for (const line of lines) {
      const m = line.match(timeRe);
      if (!m) continue;
      const clock = (m[2] || m[4] || '').trim();
      let desc = line.replace(timeRe,'').trim().replace(/\s+\d+\s+\d+\s*$/, '').trim();
      if (!desc) continue;
      plays.push({ clock, desc });
    }
    if (!plays.length) { alert('No valid play lines found.'); return; }

    function inferOpponentLabel(plays) {
      for (const p of plays) {
        const d = p.desc;
        const m = d.match(/^([A-Z][a-z]+(?:\s[A-Z][a-z]+)*)\s+Timeout\b/);
        if (m && !hasFullOUName(d) && !hasOUTeamWord(m[1])) return m[1];
      }
      for (const p of plays) {
        const d = p.desc;
        if (hasFullOUName(d) || hasOUTeamWord(d)) continue;
        const capsPhrase = d.match(/\b([A-Z]{3,}(?:\s+[A-Z]{3,})+)\b/);
        if (capsPhrase && !hasOUTeamWord(capsPhrase[1])) return capsPhrase[1];
        const capsWord = d.match(/\b[A-Z]{3,}\b/);
        if (capsWord && !hasOUTeamWord(capsWord[0])) return capsWord[0];
      }
      return 'Opponent';
    }
    const manual = (document.getElementById('opponent')?.value || '').trim();
    const OPP_LABEL = manual || inferOpponentLabel(plays);

    const startLabel = d => {
      if (isJumpBallToOpp(d)) return 'Jump Ball';
      if (isTO(d) && (hasFullOUName(d) || hasOUTeamWord(d))) return 'OU TO';
      if (isDReb(d) && classify(d) === 'OPP') return `${OPP_LABEL} DReb`;
      if ((isMade(d) || isFT(d)) && (hasFullOUName(d) || hasOUTeamWord(d))) return 'OU Score';
      return null;
    };
    const endLabel = d => {
      const who = classify(d);
      if (isDReb(d) && who === 'OU') return 'OU DReb';
      if (isSteal(d) && who === 'OU') return 'OU Steal';
      if (who === 'OPP') {
        if (isFT(d) && !/missed/i.test(d)) return `${OPP_LABEL} FT`;
        if (isMade(d)) return isThree(d) ? `${OPP_LABEL} 3` : `${OPP_LABEL} 2`;
      }
      if (isTO(d) && who === 'OPP') return `${OPP_LABEL} TO?`;
      return null;
    };

    const possessions = [];
    let inDef = false, startClock = null, startNote = '', n = 1;
    const endPoss = (endClock, result) => {
      possessions.push({ num:n++, start:startClock, end:endClock, action:startNote, result });
      inDef = false; startClock = null; startNote = '';
    };

    for (let i = 0; i < plays.length; i++) {
      const { clock, desc } = plays[i];

      if (!inDef) {
        if (isJumpBallToOpp(desc) ||
            (isTO(desc) && (hasFullOUName(desc) || hasOUTeamWord(desc))) ||
            (isDReb(desc) && classify(desc) === 'OPP') ||
            ((isMade(desc) || isFT(desc)) && (hasFullOUName(desc) || hasOUTeamWord(desc)))) {
          startClock = clock;
          startNote  = startLabel(desc) || 'Start';
          inDef = true;
        }
        continue;
      }

      let label = endLabel(desc);
      if (label === `${OPP_LABEL} FT` && isFT(desc) && isMiss(desc)) label = null;

      if (label === `${OPP_LABEL} TO?`) {
        let ouBall = false;
        for (let j = i + 1; j < Math.min(i + 7, plays.length); j++) {
          const nx = plays[j].desc;
          if ((hasFullOUName(nx) || hasOUTeamWord(nx)) && /made|missed/i.test(nx) && !/rebound/i.test(nx)) { ouBall = true; break; }
          if ((hasFullOUName(nx) || hasOUTeamWord(nx)) && isSteal(nx)) { ouBall = true; break; }
          if (classify(nx) === 'OPP' && (isMade(nx) || (isFT(nx) && !/missed/i.test(nx)) || isDReb(nx))) break;
        }
        label = ouBall ? `${OPP_LABEL} TO` : null;
      }

      if (label) { endPoss(clock, label); continue; }
      if (isOReb(desc) && classify(desc) === 'OPP') continue;
    }

    if (!possessions.length) { alert('No defensive possessions found.'); return; }

    let out = '#  Clock Range   Action → Result\n';
    for (const p of possessions)
      out += `${p.num}  ${p.start} → ${p.end}  ${p.action} → ${p.result}\n`;
    pbpTextEl.value = out;
    alert(`✅ Processed ${possessions.length} OU defensive possessions`);
  }
})();
</script>

<!-- -------- Floating overlay picker (single system, multi-pick) -------- -->
<script>
(function initFloatingPickers(){
  // Create (or reuse) the floating panel
  let fp = document.getElementById('floatPicker');
  if (!fp) {
    fp = document.createElement('div');
    fp.id = 'floatPicker';
    fp.style.display = 'none';
    document.body.appendChild(fp);
  }

  let cur = null;
  let options = [];
  let fpOpenDirection = null; // 'below' | 'above' | null (lock during one open session)

  // Allow clicking without blurring the input
  fp.addEventListener('mousedown', e => e.preventDefault());

  function render(filter=''){
    const f = (filter||'').toLowerCase();
    const list = options.filter(o => o.toLowerCase().includes(f));
    fp.innerHTML = list.length
      ? list.map(o=>`<div class="fp-item" data-val="${o}">${o}</div>`).join('')
      : `<div class="fp-empty">No matches</div>`;
  }

  function positionTo(input){
    const r = input.getBoundingClientRect();
    const margin = 6;
    const vh = window.innerHeight;
    const below = vh - r.bottom - margin; // space below input
    const above = r.top - margin;         // space above input

    // Tunables (stable + no flicker)
    const preferred = 110; // desired max height of list
    const minHeight = 95; // minimum usable list height
    const buffer = 8;      // breathing room from viewport edges

    // First placement in a session: decide and lock direction
    if (!fpOpenDirection) {
      // prefer below unless above is clearly better
      fpOpenDirection = (below >= above - 20) ? 'below' : 'above';
    }

    // Calculate the height based on the locked direction
    const avail = fpOpenDirection === 'below' ? (below - buffer) : (above - buffer);
    const h = Math.max(minHeight, Math.min(preferred, Math.max(0, avail)));

    // Size & place next to the input
    fp.style.minWidth = Math.max(150, r.width) + 'px';
    fp.style.maxHeight = h + 'px';
    fp.style.left = Math.round(r.left) + 'px';
    fp.style.top  = fpOpenDirection === 'below'
      ? Math.round(r.bottom + margin) + 'px'
      : Math.round(r.top - margin - h) + 'px';
  }

  function openFor(input){
    cur = input;
    fpOpenDirection = null;      // reset lock for this open session

    // Cache datalist id then remove native UI (Safari/Chrome)
    if (!input.dataset.fpList) {
      const id = input.getAttribute('list');
      if (!id) return close();
      input.dataset.fpList = id;
      input.removeAttribute('list');
      input.setAttribute('autocomplete','off');
    }
    const dl = document.getElementById(input.dataset.fpList);
    if (!dl) return close();

    // Read options, render & show
    options = Array.from(dl.querySelectorAll('option')).map(o=>o.value);
    const token = input.value.split(',').slice(-1)[0].trim();
    render(token);
    fp.style.display = 'block';
    positionTo(input);
  }

  function close(){
    fp.style.display = 'none';
    cur = null;
    fpOpenDirection = null;
  }

  // Click to select (always multi-append)
  fp.addEventListener('click', (e)=>{
    const it = e.target.closest('.fp-item');
    if (!it || !cur) return;
    const val = it.dataset.val || it.textContent;

    const parts = cur.value.split(',').map(s=>s.trim()).filter(Boolean);
    parts.push(val);
    cur.value = parts.join(', ') 

    // keep caret at end and keep list open for more picks
    requestAnimationFrame(()=>{
      cur.focus();
      cur.selectionStart = cur.selectionEnd = cur.value.length;
    });
    render('');
    positionTo(cur);
  });

  // Attach only to inputs that originally had a datalist
  const inputs = Array.from(document.querySelectorAll('input[list]'));
  inputs.forEach(inp=>{
    // Open on focus
    inp.addEventListener('focus', ()=> openFor(inp));

    // Filter while typing; keep open
    inp.addEventListener('input', ()=>{
      if (!cur) openFor(inp);
      const token = inp.value.split(',').slice(-1)[0].trim();
      render(token);
      positionTo(inp);
    });

    // Enter picks first, Esc/Tab closes
    inp.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter'){
        const first = fp.querySelector('.fp-item');
        if (first){ first.click(); e.preventDefault(); }
      }
      if (e.key === 'Escape' || e.key === 'Tab') close();
    });

    // After delimiters, show full list again (stay open)
    inp.addEventListener('keyup', (e)=>{
      if (e.key === ',' || e.key === '+'){
        if (!/\s$/.test(inp.value)) inp.value += ' ';
        render('');
        positionTo(inp);
      }
    });

    // Genuine blur closes (clicks on panel don't blur because of mousedown preventDefault)
    inp.addEventListener('blur', ()=> setTimeout(()=>{
      if (!document.activeElement || document.activeElement === document.body) close();
    }, 0));
  });

  // Outside click closes
  document.addEventListener('mousedown', (e)=>{
    if (fp.style.display === 'none') return;
    if (cur && (e.target === cur || fp.contains(e.target))) return;
    close();
  });

  // Reposition on scroll/resize without flipping direction
  window.addEventListener('scroll', ()=>{ if (cur) positionTo(cur); }, true);
  window.addEventListener('resize', ()=>{ if (cur) positionTo(cur); });
})();

// ===== Keyboard Shortcuts =====
document.addEventListener('keydown', e => {
  // Ignore key presses while typing in inputs or textareas
  if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;

  switch (e.key.toLowerCase()) {
    case 'arrowleft':  // ← Jump back 10s
      skipVideo(-10);
      break;
    case 'arrowright': // → Jump forward 10s
      skipVideo(10);
      break;
    case 'i':          // Mark IN
      document.getElementById('markIn')?.click();
      break;
    case 'o':          // Mark OUT
      document.getElementById('markOut')?.click();
      break;
    case 's':          // Save clip
      document.getElementById('save')?.click();
      break;
    case '1':          // 0.5x speed
      setSpeed(0.5);
      break;
    case '2':          // 1x speed
      setSpeed(1);
      break;
    case '3':          // 2x speed
      setSpeed(2);
      break;
  }
});

// helpers (if not already defined)
function skipVideo(seconds) {
  const vid = document.querySelector('video');
  if (!vid) return;
  vid.currentTime += seconds;
}
function setSpeed(rate) {
  const vid = document.querySelector('video');
  if (!vid) return;
  vid.playbackRate = rate;
}

// ===== Keyboard Shortcuts =====
document.addEventListener('keydown', e => {
  if (['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) return;
  switch (e.key.toLowerCase()) {
    case 'arrowleft':  skipVideo(2); break;
    case 'arrowright': skipVideo(2);  break;
    case 'i':          document.getElementById('markIn')?.click();  break;
    case 'o':          document.getElementById('markOut')?.click(); break;
    case 's':          document.getElementById('save')?.click();    break;
    case '1': setSpeed(0.5); break;
    case '2': setSpeed(1);   break;
    case '3': setSpeed(2);   break;
  }
});
function skipVideo(seconds){ const vid=document.querySelector('video'); if(vid) vid.currentTime += seconds; }
function setSpeed(rate){     const vid=document.querySelector('video'); if(vid) vid.playbackRate = rate; }

// ---- Export all tag fields (no headers) ----
function exportClipsCSV(){
  try {
    if (!Array.isArray(window.clips)) {
      alert('Clips storage not found.');
      return;
    }
    if (!clips.length) {
      alert('No clips to export.');
      return;
    }

    // exact column order used in your Tagger layout
    const ORDER = [
      'Game #',
      'Location',
      'Opponent',
      'Quarter',
      'Possession #',
      'Situation',
      'Offensive Formation',
      'Play Name',
      'Covered in Scout?',
      'Action Trigger',
      'Action Type(s)',
      'Action Sequence',
      'Defensive Coverage',
      'Ball Screen Coverage',
      'Off-Ball Screen Coverage',
      'Help/Rotation',
      'Defensive Disruption',
      'Defensive Breakdown',
      'Play Result',
      'Paint Touches',
      'Shooter Designation',
      'Shot Location',
      'Shot Contest',
      'Rebound Outcome',
      'Points',
      'Notes',
      'Start Time',
      'End Time'
    ];

    const esc = v => {
      const s = String(v ?? '');
      return /[",\n]/.test(s) ? `"${s.replace(/"/g,'""')}"` : s;
    };

    const rawHeader = ORDER.map(key => esc(key)).join(',');
    const rawRows = clips.map(clip => ORDER.map(key => esc(clip[key] ?? '')));
    const rawCsv = [rawHeader, ...rawRows.map(row => row.join(','))].join('\r\n');

    const opp   = document.getElementById('opponent')?.value?.trim() || 'Opponent';
    const game  = document.getElementById('gameNum')?.value?.trim() || 'Game';
    const stamp = new Date().toISOString().replace(/[-:T]/g,'').slice(0,14);
    const rawName = `Tagging_raw_${opp}_${game}_${stamp}.csv`.replace(/\s+/g,'_');
    downloadCsv(rawName, '\ufeff' + rawCsv);

    const NORMALIZED_ORDER = [
      'id','game','opponent','quarter','possession',
      'location','location_display','location_code',
      'situation','offensive_formation','play_name',
      'scout_coverage','action_trigger','action_types','action_sequence',
      'defensive_coverage','ball_screen_coverage','off_ball_screen_coverage','help_rotation',
      'defensive_disruption','defensive_breakdown','result','paint_touches',
      'shooter_designation','shot_location','shot_contest','rebound_outcome',
      'points','notes','start_time','end_time','filename','video_path'
    ];

    const normalizedHeader = NORMALIZED_ORDER.map(key => esc(key)).join(',');
    const normalizedRows = clips.map(clip => {
      const normalized = { ...toNormalizedPayload(clip) };
      const { code, display } = ensureLocationSnapshot(clip);
      normalized.location = normalized.location || code || display;
      normalized.location_display = normalized.location_display || display;
      normalized.location_code = normalized.location_code || code;
      normalized.filename = normalized.filename || clip.filename || (window.currentVideoFile?.name || '');
      normalized.video_path = normalized.video_path || clip.video_path || (window.currentVideoPath || '');
      normalized.id = normalized.id || clip.__clipId || clip.id || `${clip['Game #'] || ''}_${clip['Quarter'] || ''}_${clip['Possession #'] || ''}`;
      return NORMALIZED_ORDER.map(key => esc(normalized[key] ?? ''));
    });
    const normalizedCsv = [normalizedHeader, ...normalizedRows.map(row => row.join(','))].join('\r\n');
    const normalizedName = `Tagging_normalized_${opp}_${game}_${stamp}.csv`.replace(/\s+/g,'_');
    downloadCsv(normalizedName, '\ufeff' + normalizedCsv);

    alert('Exported raw and normalized CSV files.');
  } catch (err) {
    console.error('Export CSV failed:', err);
    alert('Export failed. See console for details.');
  }
}
document.addEventListener('DOMContentLoaded', () => {
  document.getElementById('exportCsv')?.addEventListener('click', exportClipsCSV);
});

</script>

<script>
(function TaggerShotOptional_v1(){
  const cb = document.getElementById('includeShot');
  const x = document.getElementById('shotX');
  const y = document.getElementById('shotY');
  const res = document.getElementById('shotResultPicker');
  const des = document.getElementById('shotDesigPicker');
  if (!cb) return;

  const fields = [x, y, res, des];
  function syncDisabled(){
    const off = !cb.checked;
    fields.forEach(el=>{
      if(!el) return;
      el.disabled = off;
      el.style.opacity = off ? '0.6' : '1';
    });
  }
  cb.addEventListener('change', syncDisabled);
  syncDisabled();

  window.renderMiniShot = function(container, X, Y, designation, result){
  if (!container || isNaN(X) || isNaN(Y)) return;
  container.innerHTML = '';
  const wrap = document.createElement('div'); wrap.className='mini-shot';
    wrap.innerHTML = '<svg viewBox="0 0 100 100" aria-hidden="true"></svg>';
    const svg = wrap.querySelector('svg');
    const NS='http://www.w3.org/2000/svg';
    const rootStyles = getComputedStyle(document.documentElement);
    const COLORS={
      designation:{
        Blue: rootStyles.getPropertyValue('--col-blue') || '#3aa3ff',
        Green: rootStyles.getPropertyValue('--col-green') || '#30d158',
        Black: rootStyles.getPropertyValue('--col-black') || '#9ca3af'
      },
      result:{
        Made: rootStyles.getPropertyValue('--col-made') || '#24c94a',
        Missed: rootStyles.getPropertyValue('--col-miss') || '#e34a4a'
      }
    };
    function halfPath(cx,cy,r,side){
      const s=side==='left'?Math.PI/2:-Math.PI/2, e=side==='left'?-Math.PI/2:Math.PI/2, sw=side==='left'?0:1;
      const x1=cx+r*Math.cos(s), y1=cy+r*Math.sin(s), x2=cx+r*Math.cos(e), y2=cy+r*Math.sin(e);
      return `M ${cx} ${cy} L ${x1} ${y1} A ${r} ${r} 0 0 ${sw} ${x2} ${y2} Z`;
    }
    const cx=Math.max(0, Math.min(100, X));
    const cy=Math.max(0, Math.min(100, 100 - Y));
    const r=4.0;
    const L=document.createElementNS(NS,'path');
    const R=document.createElementNS(NS,'path');
    const Ring=document.createElementNS(NS,'circle');
    L.setAttribute('d',halfPath(cx,cy,r,'left'));
    R.setAttribute('d',halfPath(cx,cy,r,'right'));
    const desKey = /blue/i.test(designation)?'Blue':/green/i.test(designation)?'Green':/black/i.test(designation)?'Black':'Black';
    const resKey = /made/i.test(result||'')?'Made':'Missed';
    L.setAttribute('fill', COLORS.designation[desKey] || COLORS.designation.Black);
    R.setAttribute('fill', COLORS.result[resKey] || COLORS.result.Missed);
    Ring.setAttribute('cx',cx); Ring.setAttribute('cy',cy); Ring.setAttribute('r',r);
    Ring.setAttribute('stroke','#000'); Ring.setAttribute('stroke-width','.5'); Ring.setAttribute('fill','none'); Ring.setAttribute('opacity','0.45');
    svg.appendChild(L); svg.appendChild(R); svg.appendChild(Ring);
    container.appendChild(wrap);
  };

  const saveBtn = document.getElementById('save') || document.querySelector('[data-action="save"]');
  if (saveBtn){
    saveBtn.addEventListener('click', ()=>{
      setTimeout(()=>{
        if (!window._lastClipData) return;
        const include = !!cb.checked;
        const shotX = include ? (x?.value || '') : '';
        const shotY = include ? (y?.value || '') : '';
        window._lastClipData['Has Shot'] = include ? 'Yes' : 'No';
        window._lastClipData['Shot X'] = shotX;
        window._lastClipData['Shot Y'] = shotY;
        if (window.clipData) {
          window.clipData['Has Shot'] = window._lastClipData['Has Shot'];
          window.clipData['Shot X'] = shotX;
          window.clipData['Shot Y'] = shotY;
        }
      },0);
    });
  }

  const hookNames=['renderQueueItem','addClipToQueue','appendQueueItem'];
  hookNames.forEach(name=>{
    const fn = window[name];
    if (typeof fn==='function' && !fn._shotWrap){
      window[name] = function(item){
        const el = fn.apply(this, arguments);
        try{
          const has = (item && item['Has Shot']==='Yes' && item['Shot X']!=='' && item['Shot Y']!=='');
          if (has && typeof window.renderMiniShot === 'function'){
            const tgt = (el && el.querySelector) ? (el.querySelector('.queue-meta')||el) : el;
            const desig = item['Shooter Designation'] || 'Black';
            const res   = (/made/i.test(item['Play Result']||'')) ? 'Made' : 'Missed';
            window.renderMiniShot(tgt, parseFloat(item['Shot X']), parseFloat(item['Shot Y']), desig, res);
          }
        }catch(_){ }
        return el;
      };
      window[name]._shotWrap = true;
    }
  });

if (typeof window.renderQueue === 'function') {
  requestAnimationFrame(()=>{ window.renderQueue(); });
}
})();
</script>
<script>
/* ===== Shot Picker: SVG marker over static court ===== */
(function(){
  const COLORS = {
    designation: {
      blue: 'var(--col-blue)',
      green: 'var(--col-green)',
      black: 'var(--col-black)'
    },
    result: {
      made: 'var(--col-made)',
      missed: 'var(--col-miss)'
    }
  };

  const courtEl = document.getElementById('shotCourt');
  const overlay = document.getElementById('shotOverlay');
  const xEl = document.getElementById('shotX');
  const yEl = document.getElementById('shotY');
  const resEl = document.getElementById('shotResultPicker');
  const desEl = document.getElementById('shotDesigPicker');

  if (!courtEl || !overlay) return;

  const NS = 'http://www.w3.org/2000/svg';
  while (overlay.firstChild) overlay.removeChild(overlay.firstChild);

  function arcPoints(cx, cy, r, startDeg, endDeg, steps = 24){
    const pts = [];
    const start = startDeg * Math.PI / 180;
    const end   = endDeg   * Math.PI / 180;
    const step  = (end - start) / steps;
    for (let i = 0; i <= steps; i++){
      const t = start + step * i;
      pts.push([
        cx + r * Math.cos(t),
        cy - r * Math.sin(t)
      ]);
    }
    return pts;
  }

  function halfPath(cx,cy,r,side){
    const pts = side === 'left'
      ? arcPoints(cx,cy,r,90,270)
      : arcPoints(cx,cy,r,-90,90);
    if (!pts.length) return '';
    let d = `M ${cx} ${cy} L ${pts[0][0]} ${pts[0][1]}`;
    for (let i = 1; i < pts.length; i++){
      d += ` L ${pts[i][0]} ${pts[i][1]}`;
    }
    return d + ' Z';
  }

  const markerGroup = document.createElementNS(NS,'g');
  const left = document.createElementNS(NS,'path');
  const right = document.createElementNS(NS,'path');
  const ring = document.createElementNS(NS,'circle');
  left.setAttribute('class','mrk-half-left');
  right.setAttribute('class','mrk-half-right');
  ring.setAttribute('class','mrk-ring');
  left.setAttribute('stroke','none');
  right.setAttribute('stroke','none');
  markerGroup.appendChild(left);
  markerGroup.appendChild(right);
  markerGroup.appendChild(ring);
  overlay.appendChild(markerGroup);

  function designationColor(){
    const raw = (desEl?.value ?? document.getElementById('shooterDesignation')?.value ?? '').trim().toLowerCase();
    if (!raw) return COLORS.designation.black;
    if (raw.includes('blue')) return COLORS.designation.blue;
    if (raw.includes('green')) return COLORS.designation.green;
    if (raw.includes('black')) return COLORS.designation.black;
    return COLORS.designation.black;
  }
  function resultColor(){
    const pick = (resEl?.value ?? '').trim().toLowerCase();
    if (pick) {
      if (pick.includes('made')) return COLORS.result.made;
      if (pick.includes('miss')) return COLORS.result.missed;
    }
    const pr = (document.getElementById('playResult')?.value || '').toLowerCase();
    return pr.includes('made') ? COLORS.result.made : COLORS.result.missed;
  }

  function redrawMarker(){
    const x = Math.max(0, Math.min(100, parseFloat(xEl.value)||0));
    const y = Math.max(0, Math.min(100, parseFloat(yEl.value)||0));
    const cx = x;
    const cy = 100 - y;
    const r = 1.8;

    left.setAttribute('d', halfPath(cx,cy,r,'left'));
    right.setAttribute('d', halfPath(cx,cy,r,'right'));
    left.setAttribute('fill', designationColor());
    right.setAttribute('fill', resultColor());

    ring.setAttribute('cx', cx);
    ring.setAttribute('cy', cy);
    ring.setAttribute('r', r);
  }

  function handleClick(evt){
    const rect = overlay.getBoundingClientRect();
    const nx = ((evt.clientX - rect.left) / rect.width) * 100;
    const ny = ((evt.clientY - rect.top) / rect.height) * 100;
    const X = Math.max(0, Math.min(100, nx));
    const Y = Math.max(0, Math.min(100, 100 - ny));
    xEl.value = X.toFixed(1);
    yEl.value = Y.toFixed(1);
    redrawMarker();
  }

  overlay.addEventListener('click', handleClick);
  xEl?.addEventListener('input', redrawMarker);
  yEl?.addEventListener('input', redrawMarker);
  resEl?.addEventListener('change', redrawMarker);
  desEl?.addEventListener('change', redrawMarker);

  xEl.value = xEl.value || '';
  yEl.value = yEl.value || '';
  redrawMarker();
})();
</script>
</body>
</html>
